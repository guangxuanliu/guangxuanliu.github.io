<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title> Evbuffers：缓冲IO的功能 - 刘光轩的个人博客 </title>
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="referrer" content="no-referrer">
    <meta name="description" content="" />
    <meta property="og:site_name" content="刘光轩的个人博客" />
    <meta property="og:locale" content="en_US" />
    <meta property="og:type" content="article" />
    <meta property="og:url" content="https://guangxuanliu.github.io/blog/evbuffers%E7%BC%93%E5%86%B2io%E7%9A%84%E5%8A%9F%E8%83%BD/" />
    <meta property="og:title" content="Evbuffers：缓冲IO的功能" />
    <meta property="og:image" content="https://guangxuanliu.github.io/" />
    <meta property="og:description" content="" />

    <meta name="twitter:card" content="summary_large_image" />
    
    <meta name="twitter:title" content="Evbuffers：缓冲IO的功能" />
    <meta name="twitter:description" content="" />
    <meta name="twitter:image" content="https://guangxuanliu.github.io/" />

    <link rel="canonical" href="https://guangxuanliu.github.io/blog/evbuffers%E7%BC%93%E5%86%B2io%E7%9A%84%E5%8A%9F%E8%83%BD/">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.5.2/css/bootstrap.min.css" integrity="sha512-MoRNloxbStBcD8z3M/2BmnT+rg4IsMxPkXaGh2zD6LGNNFE80W3onsAhRcMAMrSoyWL9xD7Ert0men7vR8LUZg==" crossorigin="anonymous" />

    <link rel="stylesheet" href="https://guangxuanliu.github.io/css/custom.css" />

    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/styles/github-gist.min.css" integrity="sha512-od7JLoOTxM8w/HSKGzP9Kexc20K9p/M2zxSWsd7H1e4Ctf+8SQFtCWEZnW5u6ul5ehSECa5QmOk9ju2nQMmlVA==" crossorigin="anonymous" />
    

    

    <link rel="shortcut icon"
        href="https://guangxuanliu.github.io/images/favicon.png">

    
    <link href="https://guangxuanliu.github.io/index.xml" rel="alternate" type="application/rss+xml" title="刘光轩的个人博客" />
    
</head>

<body>
    
<div class="mt-xl header">
    <div class="container">
        <div class="row justify-content-center">
            <div class="col-auto">
                <a href="https://guangxuanliu.github.io/">
                    <h1 class="name">刘光轩的个人博客</h1>
                </a>
            </div>
        </div>

        <div class="row justify-content-center">
            <ul class="nav nav-primary">
                
                <li class="nav-item">
                    <a class="nav-link" href="https://guangxuanliu.github.io/">
                        
                        主页
                    </a>
                </li>
                
                <li class="nav-item">
                    <a class="nav-link" href="https://guangxuanliu.github.io/about/">
                        
                        关于
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</div>

<div class="content">
    <div class="container">
        <div class="row justify-content-center">
            <div class="col-sm-12 col-lg-8">
                <h1 class="mx-0 mx-md-4 blog-post-title">Evbuffers：缓冲IO的功能</h1>

                <div class="mb-md-4 meta">
                    
                    
                    

                    <span class="date middot" title='Mon Sep 13 2021 20:30:35 CST'>
                        2021-09-13
                    </span>

                    <span class="reading-time middot">
                        8 min read
                    </span>

                    <div class="d-none d-md-inline tags">
                        <ul class="list-unstyled d-inline">
                            
                        </ul>
                    </div>
                </div>

                <div class="markdown blog-post-content">
                    
    <p>Libevent 的 <code>evbuffer</code> 功能实现了一个字节队列，针对将数据添加到末尾和从前面删除数据进行了优化。</p>
<p>Evbuffers 通常用于执行缓冲网络 IO 的“缓冲”部分。它们不提供调度 IO 或在 IO 准备好时触发 IO 的功能：这是 bufferevents 所做的功能。</p>
<p>除非特别说明，本章的所有函数声明在<code>event2/buffer.h</code>头文件中。</p>
<h4 id="创建或释放evbuffer">创建或释放evbuffer</h4>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#00f">struct</span> <span style="color:#2b91af">evbuffer</span> *evbuffer_new(<span style="color:#2b91af">void</span>);
<span style="color:#2b91af">void</span> evbuffer_free(<span style="color:#00f">struct</span> <span style="color:#2b91af">evbuffer</span> *buf);
</code></pre></div><p><code>evbuffer_new()</code>分配内存并且返回一个新的空的evbuffer，<code>evbuffer_free()</code>释放并且清除evbuffer的内容。</p>
<h4 id="evbuffer与线程安全">evbuffer与线程安全</h4>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#2b91af">int</span> evbuffer_enable_locking(<span style="color:#00f">struct</span> <span style="color:#2b91af">evbuffer</span> *buf, <span style="color:#2b91af">void</span> *lock);
<span style="color:#2b91af">void</span> evbuffer_lock(<span style="color:#00f">struct</span> <span style="color:#2b91af">evbuffer</span> *buf);
<span style="color:#2b91af">void</span> evbuffer_unlock(<span style="color:#00f">struct</span> <span style="color:#2b91af">evbuffer</span> *buf);
</code></pre></div><p>默认情况下，同时在多个线程中访问evbuffer并不是安全的。如果需要在多线程中访问，你需要在evbuffer上调用<code>evbuffer_enable_locking()</code>，如果<code>lock</code>参数为NULL，libevent使用使用<code>evthread_set_lock_creation_callback</code>函数的锁创建函数来分配一个新的锁。如果<code>lock</code>参数不为空的话，则用之作为锁。</p>
<p><code>evbuffer_lock()</code>和<code>evbuffer_unlock()</code>函数分别获取和释放锁。你可以使用它们来进行一系列的原子操作。如果evbuffer没有启用加锁，则这些函数调用无效。</p>
<p>（注意，单个操作无须调用<code>evbuffer_lock()</code>和<code>evbuffer_unlock()</code>，如果evbuffer启用了加锁，单个操作已经是原子的了。只有在多线程同时有多个操作的情况下手动锁定evbuffer。）</p>
<h4 id="检查evbuffer">检查evbuffer</h4>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">size_t evbuffer_get_length(<span style="color:#00f">const</span> <span style="color:#00f">struct</span> <span style="color:#2b91af">evbuffer</span> *buf);
</code></pre></div><p>该函数返回存储在evbuffer中的字节数。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">size_t evbuffer_get_contiguous_space(<span style="color:#00f">const</span> <span style="color:#00f">struct</span> <span style="color:#2b91af">evbuffer</span> *buf);
</code></pre></div><p>该函数返回evbuffer中前面连续的字节数。evbuffer的字节可能存储在多个分散的内存块中，这个函数返回第一个内存块中连续的字节数。</p>
<h4 id="向evbuffer添加数据">向evbuffer添加数据</h4>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#2b91af">int</span> evbuffer_add(<span style="color:#00f">struct</span> <span style="color:#2b91af">evbuffer</span> *buf, <span style="color:#00f">const</span> <span style="color:#2b91af">void</span> *data, size_t datlen);
</code></pre></div><p>该函数将以data起始的datlen长度的数据添加到buf的尾部。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#2b91af">int</span> evbuffer_add_printf(<span style="color:#00f">struct</span> <span style="color:#2b91af">evbuffer</span> *buf, <span style="color:#00f">const</span> <span style="color:#2b91af">char</span> *fmt, ...)
<span style="color:#2b91af">int</span> evbuffer_add_vprintf(<span style="color:#00f">struct</span> <span style="color:#2b91af">evbuffer</span> *buf, <span style="color:#00f">const</span> <span style="color:#2b91af">char</span> *fmt, va_list ap);
</code></pre></div><p>上述两个函数向buf的尾部添加格式化的数据，fmt参数及后续的参数同C函数的<code>printf</code>和<code>vprintf</code>，这两个函数均返回添加的字节数。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#2b91af">int</span> evbuffer_expand(<span style="color:#00f">struct</span> <span style="color:#2b91af">evbuffer</span> *buf, size_t datlen);
</code></pre></div><p>此函数修改缓冲区的最后一个内存块，或者新增一个内存块，使evbuffer不用再进行分配内存便可以存入datlen长度的数据。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#008000">/* Here are two ways to add &#34;Hello world 2.0.1&#34; to a buffer. */</span>
<span style="color:#008000">/* Directly: */</span>
evbuffer_add(buf, <span style="color:#a31515">&#34;Hello world 2.0.1&#34;</span>, 17);

<span style="color:#008000">/* Via printf: */</span>
evbuffer_add_printf(buf, <span style="color:#a31515">&#34;Hello %s %d.%d.%d&#34;</span>, <span style="color:#a31515">&#34;world&#34;</span>, 2, 0, 1);
</code></pre></div><h4 id="从一个evbuffer移动数据到另一个evbuffer">从一个evbuffer移动数据到另一个evbuffer</h4>
<p>为了提高效率，libevent优化了从一个evbuffer移动数据到另一个evbuffer的功能。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#2b91af">int</span> evbuffer_add_buffer(<span style="color:#00f">struct</span> <span style="color:#2b91af">evbuffer</span> *dst, <span style="color:#00f">struct</span> <span style="color:#2b91af">evbuffer</span> *src);
<span style="color:#2b91af">int</span> evbuffer_remove_buffer(<span style="color:#00f">struct</span> <span style="color:#2b91af">evbuffer</span> *src, <span style="color:#00f">struct</span> <span style="color:#2b91af">evbuffer</span> *dst,
    size_t datlen);
</code></pre></div><p><code>evbuffer_add_buffer()</code>函数把src中的所有数据移动到dst中。成功时返回0，失败时返回-1.</p>
<p><code>evbuffer_remove_buffer()</code>函数把src中datlen长度字节的数据移动到dst中，尽可能少的减少复制。如果src中的数据少于datlen，则将src中的数据全部移动到dst中。该函数返回移动的字节数。</p>
<h4 id="向evbuffer的头部添加数据">向evbuffer的头部添加数据</h4>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#2b91af">int</span> evbuffer_prepend(<span style="color:#00f">struct</span> <span style="color:#2b91af">evbuffer</span> *buf, <span style="color:#00f">const</span> <span style="color:#2b91af">void</span> *data, size_t size);
<span style="color:#2b91af">int</span> evbuffer_prepend_buffer(<span style="color:#00f">struct</span> <span style="color:#2b91af">evbuffer</span> *dst, <span style="color:#00f">struct</span> <span style="color:#2b91af">evbuffer</span>* src);
</code></pre></div><p>这两个函数和<code>evbuffer_add()</code>、<code>evbuffer_add_buffer()</code>类似，不过这两个函数向evbuffer的头部添加数据。</p>
<h4 id="重新调整evbuffer的内部布局">重新调整evbuffer的内部布局</h4>
<p>有时你想要检查evbuffer的前N个字节的数据，并将其视为连续的字节数组。为了达到此目的，你首先要确保evbuffer的前端确实是连续的。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#2b91af">unsigned</span> <span style="color:#2b91af">char</span> *evbuffer_pullup(<span style="color:#00f">struct</span> <span style="color:#2b91af">evbuffer</span> *buf, ev_ssize_t size);
</code></pre></div><p><code>evbuffer_pullup()</code>函数线性化buf的前size字节，如果需要的话，进行数据的拷贝和移动以确保它们在同一块连续的内存块上。如果size参数为负数，此函数线性化整个buf，如果size大于buf的长度，则返回NULL。正常情况下，<code>evbuffer_pullup()</code>函数返回第一个字节的指针。</p>
<p>当给size指定很大的值的时候调用此函数，可能会很慢，因为可能需要拷贝整个缓冲区的内容。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#00f">#include</span> <span style="color:#00f">&lt;event2/buffer.h&gt;</span><span style="color:#00f">
</span><span style="color:#00f">#include</span> <span style="color:#00f">&lt;event2/util.h&gt;</span><span style="color:#00f">
</span><span style="color:#00f"></span>
<span style="color:#00f">#include</span> <span style="color:#00f">&lt;string.h&gt;</span><span style="color:#00f">
</span><span style="color:#00f"></span>
<span style="color:#2b91af">int</span> parse_socks4(<span style="color:#00f">struct</span> <span style="color:#2b91af">evbuffer</span> *buf, ev_uint16_t *port, ev_uint32_t *addr)
{
    <span style="color:#008000">/* Let&#39;s parse the start of a SOCKS4 request!  The format is easy:
</span><span style="color:#008000">     * 1 byte of version, 1 byte of command, 2 bytes destport, 4 bytes of
</span><span style="color:#008000">     * destip. */</span>
    <span style="color:#2b91af">unsigned</span> <span style="color:#2b91af">char</span> *mem;

    mem = evbuffer_pullup(buf, 8);

    <span style="color:#00f">if</span> (mem == NULL) {
        <span style="color:#008000">/* Not enough data in the buffer */</span>
        <span style="color:#00f">return</span> 0;
    } <span style="color:#00f">else</span> <span style="color:#00f">if</span> (mem[0] != 4 || mem[1] != 1) {
        <span style="color:#008000">/* Unrecognized protocol or command */</span>
        <span style="color:#00f">return</span> -1;
    } <span style="color:#00f">else</span> {
        memcpy(port, mem+2, 2);
        memcpy(addr, mem+4, 4);
        *port = ntohs(*port);
        *addr = ntohl(*addr);
        <span style="color:#008000">/* Actually remove the data from the buffer now that we know we
</span><span style="color:#008000">           like it. */</span>
        evbuffer_drain(buf, 8);
        <span style="color:#00f">return</span> 1;
    }
}
</code></pre></div><p>注意：以<code>evbuffer_get_contiguous_space()</code>返回值为参数调用<code>evbuffer_pullup()</code>并不会导致任何数据的移动和拷贝。</p>
<h4 id="从evbuffer中移除数据">从evbuffer中移除数据</h4>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#2b91af">int</span> evbuffer_drain(<span style="color:#00f">struct</span> <span style="color:#2b91af">evbuffer</span> *buf, size_t len);
<span style="color:#2b91af">int</span> evbuffer_remove(<span style="color:#00f">struct</span> <span style="color:#2b91af">evbuffer</span> *buf, <span style="color:#2b91af">void</span> *data, size_t datlen);
</code></pre></div><p><code>evbuffer_remove()</code>函数拷贝datlen字节的数据值data中，并且移除原来的数据。如果可用的长度小于datlen，则此函数拷贝所有的字节。该函数失败时返回-1，成功时返回拷贝的字节数。</p>
<p><code>evbuffer_drain()</code>和<code>evbuffer_remove()</code>函数类似。但是它只是移除数据，并不进行拷贝。该函数在成功时返回0，失败时返回-1.</p>
<h4 id="从evbuffer中拷贝数据">从evbuffer中拷贝数据</h4>
<p>有时你只想从evbuffer的起始位置拷贝数据，但是并不想移除。例如，你只想看看是否到了一个完整的记录，而不想移除或者重新排列缓冲区。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">ev_ssize_t evbuffer_copyout(<span style="color:#00f">struct</span> <span style="color:#2b91af">evbuffer</span> *buf, <span style="color:#2b91af">void</span> *data, size_t datlen);
ev_ssize_t evbuffer_copyout_from(<span style="color:#00f">struct</span> <span style="color:#2b91af">evbuffer</span> *buf,
     <span style="color:#00f">const</span> <span style="color:#00f">struct</span> <span style="color:#2b91af">evbuffer_ptr</span> *pos,
     <span style="color:#2b91af">void</span> *data_out, size_t datlen);
</code></pre></div><p><code>evbuffer_copyout()</code>和<code>evbuffer_remove()</code>类似，但是并不从缓冲区中移除数据。他将datlen字节的数据拷贝到data所在的内存中，如果buf中长度小于datlen，该函数拷贝所有的字节数。该函数在成功时返回拷贝的字节数，在失败时返回-1.</p>
<p><code>evbuffer_copyout_from()</code>函数和<code>evbuffer_copyout()</code>函数类似，但是它不是从buf的起始位置拷贝数据，而是从pos开始的位置进行拷贝。有关<code>evbuffer_ptr</code>的更多信息，请参考“搜索evbuffer”小节。</p>
<p>如果从evbuffer中拷贝数据太慢了，请使用<code>evbuffer_peek()</code>函数代替。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#00f">#include</span> <span style="color:#00f">&lt;event2/buffer.h&gt;</span><span style="color:#00f">
</span><span style="color:#00f">#include</span> <span style="color:#00f">&lt;event2/util.h&gt;</span><span style="color:#00f">
</span><span style="color:#00f">#include</span> <span style="color:#00f">&lt;stdlib.h&gt;</span><span style="color:#00f">
</span><span style="color:#00f">#include</span> <span style="color:#00f">&lt;stdlib.h&gt;</span><span style="color:#00f">
</span><span style="color:#00f"></span>
<span style="color:#2b91af">int</span> get_record(<span style="color:#00f">struct</span> <span style="color:#2b91af">evbuffer</span> *buf, size_t *size_out, <span style="color:#2b91af">char</span> **record_out)
{
    <span style="color:#008000">/* Let&#39;s assume that we&#39;re speaking some protocol where records
</span><span style="color:#008000">       contain a 4-byte size field in network order, followed by that
</span><span style="color:#008000">       number of bytes.  We will return 1 and set the &#39;out&#39; fields if we
</span><span style="color:#008000">       have a whole record, return 0 if the record isn&#39;t here yet, and
</span><span style="color:#008000">       -1 on error.  */</span>
    size_t buffer_len = evbuffer_get_length(buf);
    ev_uint32_t record_len;
    <span style="color:#2b91af">char</span> *record;

    <span style="color:#00f">if</span> (buffer_len &lt; 4)
       <span style="color:#00f">return</span> 0; <span style="color:#008000">/* The size field hasn&#39;t arrived. */</span>

   <span style="color:#008000">/* We use evbuffer_copyout here so that the size field will stay on
</span><span style="color:#008000">       the buffer for now. */</span>
    evbuffer_copyout(buf, &amp;record_len, 4);
    <span style="color:#008000">/* Convert len_buf into host order. */</span>
    record_len = ntohl(record_len);
    <span style="color:#00f">if</span> (buffer_len &lt; record_len + 4)
        <span style="color:#00f">return</span> 0; <span style="color:#008000">/* The record hasn&#39;t arrived */</span>

    <span style="color:#008000">/* Okay, _now_ we can remove the record. */</span>
    record = malloc(record_len);
    <span style="color:#00f">if</span> (record == NULL)
        <span style="color:#00f">return</span> -1;

    evbuffer_drain(buf, 4);
    evbuffer_remove(buf, record, record_len);

    *record_out = record;
    *size_out = record_len;
    <span style="color:#00f">return</span> 1;
}
</code></pre></div><h4 id="面向行的输入">面向行的输入</h4>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#00f">enum</span> <span style="color:#2b91af">evbuffer_eol_style</span> {
        EVBUFFER_EOL_ANY,
        EVBUFFER_EOL_CRLF,
        EVBUFFER_EOL_CRLF_STRICT,
        EVBUFFER_EOL_LF,
        EVBUFFER_EOL_NUL
};
<span style="color:#2b91af">char</span> *evbuffer_readln(<span style="color:#00f">struct</span> <span style="color:#2b91af">evbuffer</span> *buffer, size_t *n_read_out,
    <span style="color:#00f">enum</span> <span style="color:#2b91af">evbuffer_eol_style</span> eol_style);
</code></pre></div><p>许多互联网协议使用了基于行的协议。<code>evbuffer_readln()</code>函数同evbuffer的头部提取一行，并且返回新的以NUL结尾的字符串。如果<code>n_read_out</code>非空，<code>*n_read_out</code>被设置为返回的字符串的长度。如果没有一整行可以读取，该函数返回NULL，行结束符不包括在返回的字符串中。</p>
<p>该函数理解4种类型的行结束符：</p>
<ul>
<li>
<p>EVBUFFER_EOL_LF</p>
<p>单个的回车符（\n，ASCII码为0x0A）</p>
</li>
<li>
<p>EVBUFFER_EOL_CRLF_STRICT</p>
<p>回车换行（\r\n，ASCII码为0x0D 0x0A）</p>
</li>
<li>
<p>EVBUFFER_EOL_CRLF</p>
<p>可选的回车，然后时换行（\r\n或者\n），这种格式在解析互联网协议的时候很有用，因为标准通常规定了\r\n为行结束符，但是有些非标准使用的是\n。</p>
</li>
<li>
<p>EVBUFFER_EOL_ANY</p>
<p>任意数量、任意序列的回车换行符，这种格式不太常用，主要是为了向后兼容</p>
</li>
<li>
<p>EVBUFFER_EOL_NUL</p>
<p>单字节的0，ASCII为NUL。</p>
</li>
</ul>
<p>注意：如果您使用 <code>event_set_mem_functions() </code>覆盖默认 <code>malloc</code>，则 <code>evbuffer_readln</code> 返回的字符串将由您指定的 <code>malloc-replacement </code>分配。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#2b91af">char</span> *request_line;
size_t len;

request_line = evbuffer_readln(buf, &amp;len, EVBUFFER_EOL_CRLF);
<span style="color:#00f">if</span> (!request_line) {
    <span style="color:#008000">/* The first line has not arrived yet. */</span>
} <span style="color:#00f">else</span> {
    <span style="color:#00f">if</span> (!strncmp(request_line, <span style="color:#a31515">&#34;HTTP/1.0 &#34;</span>, 9)) {
        <span style="color:#008000">/* HTTP 1.0 detected ... */</span>
    }
    free(request_line);
}
</code></pre></div><h4 id="搜索evbuffer">搜索evbuffer</h4>
<p><code>evbuffer_ptr</code> 结构指向 <code>evbuffer</code> 中的一个位置，并包含可用于遍历 <code>evbuffer</code> 的数据。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#00f">struct</span> <span style="color:#2b91af">evbuffer_ptr</span> {
        ev_ssize_t pos;
        <span style="color:#00f">struct</span> {
                <span style="color:#008000">/* internal fields */</span>
        } _internal;
};
</code></pre></div><p><code>pos</code>字段是唯一的公开字段，其余的字段使用者不应该调用，它代表着一个evbuffer从起始位置的偏移量。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#00f">struct</span> <span style="color:#2b91af">evbuffer_ptr</span> evbuffer_search(<span style="color:#00f">struct</span> <span style="color:#2b91af">evbuffer</span> *buffer,
    <span style="color:#00f">const</span> <span style="color:#2b91af">char</span> *what, size_t len, <span style="color:#00f">const</span> <span style="color:#00f">struct</span> <span style="color:#2b91af">evbuffer_ptr</span> *start);
<span style="color:#00f">struct</span> <span style="color:#2b91af">evbuffer_ptr</span> evbuffer_search_range(<span style="color:#00f">struct</span> <span style="color:#2b91af">evbuffer</span> *buffer,
    <span style="color:#00f">const</span> <span style="color:#2b91af">char</span> *what, size_t len, <span style="color:#00f">const</span> <span style="color:#00f">struct</span> <span style="color:#2b91af">evbuffer_ptr</span> *start,
    <span style="color:#00f">const</span> <span style="color:#00f">struct</span> <span style="color:#2b91af">evbuffer_ptr</span> *end);
<span style="color:#00f">struct</span> <span style="color:#2b91af">evbuffer_ptr</span> evbuffer_search_eol(<span style="color:#00f">struct</span> <span style="color:#2b91af">evbuffer</span> *buffer,
    <span style="color:#00f">struct</span> <span style="color:#2b91af">evbuffer_ptr</span> *start, size_t *eol_len_out,
    <span style="color:#00f">enum</span> <span style="color:#2b91af">evbuffer_eol_style</span> eol_style);
</code></pre></div><p><code>evbuffer_search()</code>函数在evbuffer中搜索长度为len的what字符串。如果找到了，则返回<code>evbuffer_ptr</code>，包含了字符串所在的位置，如果没找到的话，返回-1。如果指定了start参数，则从此start参数所在的位置开始搜索，否则从evbuffer的起始位置开始搜索。</p>
<p><code>evbuffer_search_range()</code>函数和<code>evbuffer_search()</code>一样，除了只搜索end之前的位置。</p>
<p><code>evbuffer_search_eol()</code>函数想<code>evbuffer_readln()</code>函数一样检测行结束符。但是并不拷贝行数据，仅仅返回<code>evbuffer_ptr</code>指向行结束符的起始位置，如果eol_len_out参数为非空，则将其设置为EOL字符串的长度。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#00f">enum</span> <span style="color:#2b91af">evbuffer_ptr_how</span> {
        EVBUFFER_PTR_SET,
        EVBUFFER_PTR_ADD
};
<span style="color:#2b91af">int</span> evbuffer_ptr_set(<span style="color:#00f">struct</span> <span style="color:#2b91af">evbuffer</span> *buffer, <span style="color:#00f">struct</span> <span style="color:#2b91af">evbuffer_ptr</span> *pos,
    size_t position, <span style="color:#00f">enum</span> <span style="color:#2b91af">evbuffer_ptr_how</span> how);
</code></pre></div><p><code>evbuffer_ptr_set</code> 函数操作缓冲区内 <code>evbuffer_ptr pos</code> 的位置。如果是 <code>EVBUFFER_PTR_SET</code>，则指针移动到缓冲区内的绝对位置。如果是 <code>EVBUFFER_PTR_ADD</code>，则指针向前移动位置字节。此函数在成功时返回 0，在失败时返回 -1。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#00f">#include</span> <span style="color:#00f">&lt;event2/buffer.h&gt;</span><span style="color:#00f">
</span><span style="color:#00f">#include</span> <span style="color:#00f">&lt;string.h&gt;</span><span style="color:#00f">
</span><span style="color:#00f"></span>
<span style="color:#008000">/* Count the total occurrences of &#39;str&#39; in &#39;buf&#39;. */</span>
<span style="color:#2b91af">int</span> count_instances(<span style="color:#00f">struct</span> <span style="color:#2b91af">evbuffer</span> *buf, <span style="color:#00f">const</span> <span style="color:#2b91af">char</span> *str)
{
    size_t len = strlen(str);
    <span style="color:#2b91af">int</span> total = 0;
    <span style="color:#00f">struct</span> <span style="color:#2b91af">evbuffer_ptr</span> p;

    <span style="color:#00f">if</span> (!len)
        <span style="color:#008000">/* Don&#39;t try to count the occurrences of a 0-length string. */</span>
        <span style="color:#00f">return</span> -1;

    evbuffer_ptr_set(buf, &amp;p, 0, EVBUFFER_PTR_SET);

    <span style="color:#00f">while</span> (1) {
         p = evbuffer_search(buf, str, len, &amp;p);
         <span style="color:#00f">if</span> (p.pos &lt; 0)
             <span style="color:#00f">break</span>;
         total++;
         evbuffer_ptr_set(buf, &amp;p, 1, EVBUFFER_PTR_ADD);
    }

    <span style="color:#00f">return</span> total;
}
</code></pre></div><h4 id="检测数据而不复制数据">检测数据，而不复制数据</h4>
<p>有时你想读取数据，但是并不进行数据的读取（evbuffer_copy()），也不进行数据的重组（evbuffer_pullup()），有时你只想查看evbuffer中间的一些数据。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#00f">struct</span> <span style="color:#2b91af">evbuffer_iovec</span> {
        <span style="color:#2b91af">void</span> *iov_base;
        size_t iov_len;
};

<span style="color:#2b91af">int</span> evbuffer_peek(<span style="color:#00f">struct</span> <span style="color:#2b91af">evbuffer</span> *buffer, ev_ssize_t len,
    <span style="color:#00f">struct</span> <span style="color:#2b91af">evbuffer_ptr</span> *start_at,
    <span style="color:#00f">struct</span> <span style="color:#2b91af">evbuffer_iovec</span> *vec_out, <span style="color:#2b91af">int</span> n_vec);
</code></pre></div><p>当你调用此函数时，<code>vec_out</code>参数代表一个数组，<code>n_vec</code>代表数组中元素的个数。该函数填充此数组，使数组元素中的<code>iov_base</code>指向evbuffer中内存块的指针，<code>iov_len</code>代表内存块的长度。</p>
<p>如果<code>len</code>参数小于0，<code>evbuffer_peek()</code>尝试填充你提供的数组的所有元素。如果<code>len</code>参数不为0，则数组中元素所指向的内存块至少包含len字节。如果你提供了数组及长度字段，该函数返回所填充的数组的个数，否则返回需要的数组元素的个数。</p>
<p>当ptr参数为NULL时，<code>evbuffer_peek()</code>从buffer的起始位置开始遍历，否则从ptr指向的位置开始遍历。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">{
    <span style="color:#008000">/* Let&#39;s look at the first two chunks of buf, and write them to stderr. */</span>
    <span style="color:#2b91af">int</span> n, i;
    <span style="color:#00f">struct</span> <span style="color:#2b91af">evbuffer_iovec</span> v[2];
    n = evbuffer_peek(buf, -1, NULL, v, 2);
    <span style="color:#00f">for</span> (i=0; i&lt;n; ++i) { <span style="color:#008000">/* There might be less than two chunks available. */</span>
        fwrite(v[i].iov_base, 1, v[i].iov_len, stderr);
    }
}

{
    <span style="color:#008000">/* Let&#39;s send the first 4906 bytes to stdout via write. */</span>
    <span style="color:#2b91af">int</span> n, i, r;
    <span style="color:#00f">struct</span> <span style="color:#2b91af">evbuffer_iovec</span> *v;
    size_t written = 0;

    <span style="color:#008000">/* determine how many chunks we need. */</span>
    n = evbuffer_peek(buf, 4096, NULL, NULL, 0);
    <span style="color:#008000">/* Allocate space for the chunks.  This would be a good time to use
</span><span style="color:#008000">       alloca() if you have it. */</span>
    v = malloc(<span style="color:#00f">sizeof</span>(<span style="color:#00f">struct</span> <span style="color:#2b91af">evbuffer_iovec</span>)*n);
    <span style="color:#008000">/* Actually fill up v. */</span>
    n = evbuffer_peek(buf, 4096, NULL, v, n);
    <span style="color:#00f">for</span> (i=0; i&lt;n; ++i) {
        size_t len = v[i].iov_len;
        <span style="color:#00f">if</span> (written + len &gt; 4096)
            len = 4096 - written;
        r = write(1 <span style="color:#008000">/* stdout */</span>, v[i].iov_base, len);
        <span style="color:#00f">if</span> (r&lt;=0)
            <span style="color:#00f">break</span>;
        <span style="color:#008000">/* We keep track of the bytes written separately; if we don&#39;t,
</span><span style="color:#008000">           we may write more than 4096 bytes if the last chunk puts
</span><span style="color:#008000">           us over the limit. */</span>
        written += len;
    }
    free(v);
}

{
    <span style="color:#008000">/* Let&#39;s get the first 16K of data after the first occurrence of the
</span><span style="color:#008000">       string &#34;start\n&#34;, and pass it to a consume() function. */</span>
    <span style="color:#00f">struct</span> <span style="color:#2b91af">evbuffer_ptr</span> ptr;
    <span style="color:#00f">struct</span> <span style="color:#2b91af">evbuffer_iovec</span> v[1];
    <span style="color:#00f">const</span> <span style="color:#2b91af">char</span> s[] = <span style="color:#a31515">&#34;start</span><span style="color:#a31515">\n</span><span style="color:#a31515">&#34;</span>;
    <span style="color:#2b91af">int</span> n_written;

    ptr = evbuffer_search(buf, s, strlen(s), NULL);
    <span style="color:#00f">if</span> (ptr.pos == -1)
        <span style="color:#00f">return</span>; <span style="color:#008000">/* no start string found. */</span>

    <span style="color:#008000">/* Advance the pointer past the start string. */</span>
    <span style="color:#00f">if</span> (evbuffer_ptr_set(buf, &amp;ptr, strlen(s), EVBUFFER_PTR_ADD) &lt; 0)
        <span style="color:#00f">return</span>; <span style="color:#008000">/* off the end of the string. */</span>

    <span style="color:#00f">while</span> (n_written &lt; 16*1024) {
        <span style="color:#008000">/* Peek at a single chunk. */</span>
        <span style="color:#00f">if</span> (evbuffer_peek(buf, -1, &amp;ptr, v, 1) &lt; 1)
            <span style="color:#00f">break</span>;
        <span style="color:#008000">/* Pass the data to some user-defined consume function */</span>
        consume(v[0].iov_base, v[0].iov_len);
        n_written += v[0].iov_len;

        <span style="color:#008000">/* Advance the pointer so we see the next chunk next time. */</span>
        <span style="color:#00f">if</span> (evbuffer_ptr_set(buf, &amp;ptr, v[0].iov_len, EVBUFFER_PTR_ADD)&lt;0)
            <span style="color:#00f">break</span>;
    }
}
</code></pre></div><p><strong>注意</strong></p>
<ul>
<li>修改<code>evbuffer_iovec</code>指向的数据将导致未定义的行为。</li>
<li>如果调用任何修改 evbuffer 的函数，则 <code>evbuffer_peek()</code> 产生的指针可能会变得无效。</li>
<li>如果evbuffer需要在多线程中使用，确保调用<code>evbuffer_peek()</code>函数之前先调用<code>evbuffer_lock()</code>，并在调用结束时调用<code>evbuffer_unlock()</code>。</li>
</ul>
<h4 id="向evbuffer中直接添加数据">向evbuffer中直接添加数据</h4>
<p>有时你想直接往evbuffer中直接添加数据，无需先将其写入字符数组，然后再调用<code>evbuffer_add()</code>进行拷贝。你可以调用一对高级的函数来达到此功能：</p>
<ul>
<li>evbuffer_reserve_space()</li>
<li>evbuffer_commit_space()</li>
</ul>
<p>就像<code>evbuffer_peek()</code>一样，这些函数使用<code>evbuffer_iovec</code>结构，来提供对evbuffer中的内存进行直接的访问。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#2b91af">int</span> evbuffer_reserve_space(<span style="color:#00f">struct</span> <span style="color:#2b91af">evbuffer</span> *buf, ev_ssize_t size,
    <span style="color:#00f">struct</span> <span style="color:#2b91af">evbuffer_iovec</span> *vec, <span style="color:#2b91af">int</span> n_vecs);
<span style="color:#2b91af">int</span> evbuffer_commit_space(<span style="color:#00f">struct</span> <span style="color:#2b91af">evbuffer</span> *buf,
    <span style="color:#00f">struct</span> <span style="color:#2b91af">evbuffer_iovec</span> *vec, <span style="color:#2b91af">int</span> n_vecs);
</code></pre></div><p><code>evbuffer_reserve_space()</code>函数返回evbuffer内部的指针，它根据需要决定是否扩展缓冲区，以便足以容纳size字节。vec中的指针指向这些扩展，n_vecs为数组的长度。</p>
<p>n_vecs的值最小必须为1，如果你只提供了一个vector，libevent将确保你所请求的空间分配在单个连续的扩展中，但是为了达到此目的，可能会重新排列内存、内存浪费。为了更好的性能，请最少提供两个vector，该函数返回你请求的空间所需的提供vector的数量。</p>
<p>在你调用 <code>evbuffer_commit_space()</code> 之前，您写入这些vector的数据不是缓冲区的一部分，这实际上使你写入的数据算作在缓冲区中。如果你想提交比你要求的更少的空间，你可以减少任何给定的 <code>evbuffer_iovec</code> 结构中的 <code>iov_len</code> 字段。您还可以传回比给定的更少的vector。 <code>evbuffer_commit_space()</code> 函数在成功时返回 0，在失败时返回 -1。</p>
<p><strong>注意</strong></p>
<ul>
<li>调用任何重新排列 evbuffer 或向evbuffer 添加数据的函数，将使您从 <code>evbuffer_reserve_space()</code> 获得的指针无效。</li>
<li>在当前实现中，<code>evbuffer_reserve_space()</code>从不使用两个以上的vector，而不论用户提供了多少。这可能会在未来的版本中改变。</li>
<li>不论调用多少次<code>evbuffer_reserve_space()</code>，总是安全的。</li>
<li>如果你的evbuffer可能在多线程中使用，确保在调用<code>evbuffer_reserve_space()</code>函数之前调用<code>evbuffer_lock()</code>，并在提交之后解锁。</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#008000">/* Suppose we want to fill a buffer with 2048 bytes of output from a
</span><span style="color:#008000">   generate_data() function, without copying. */</span>
<span style="color:#00f">struct</span> <span style="color:#2b91af">evbuffer_iovec</span> v[2];
<span style="color:#2b91af">int</span> n, i;
size_t n_to_add = 2048;

<span style="color:#008000">/* Reserve 2048 bytes.*/</span>
n = evbuffer_reserve_space(buf, n_to_add, v, 2);
<span style="color:#00f">if</span> (n&lt;=0)
   <span style="color:#00f">return</span>; <span style="color:#008000">/* Unable to reserve the space for some reason. */</span>

<span style="color:#00f">for</span> (i=0; i&lt;n &amp;&amp; n_to_add &gt; 0; ++i) {
   size_t len = v[i].iov_len;
   <span style="color:#00f">if</span> (len &gt; n_to_add) <span style="color:#008000">/* Don&#39;t write more than n_to_add bytes. */</span>
      len = n_to_add;
   <span style="color:#00f">if</span> (generate_data(v[i].iov_base, len) &lt; 0) {
      <span style="color:#008000">/* If there was a problem during data generation, we can just stop
</span><span style="color:#008000">         here; no data will be committed to the buffer. */</span>
      <span style="color:#00f">return</span>;
   }
   <span style="color:#008000">/* Set iov_len to the number of bytes we actually wrote, so we
</span><span style="color:#008000">      don&#39;t commit too much. */</span>
   v[i].iov_len = len;
}

<span style="color:#008000">/* We commit the space here.  Note that we give it &#39;i&#39; (the number of
</span><span style="color:#008000">   vectors we actually used) rather than &#39;n&#39; (the number of vectors we
</span><span style="color:#008000">   had available. */</span>
<span style="color:#00f">if</span> (evbuffer_commit_space(buf, v, i) &lt; 0)
   <span style="color:#00f">return</span>; <span style="color:#008000">/* Error committing */</span>
</code></pre></div><p>反例</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#008000">/* Here are some mistakes you can make with evbuffer_reserve().
</span><span style="color:#008000">   DO NOT IMITATE THIS CODE. */</span>
<span style="color:#00f">struct</span> <span style="color:#2b91af">evbuffer_iovec</span> v[2];

{
  <span style="color:#008000">/* Do not use the pointers from evbuffer_reserve_space() after
</span><span style="color:#008000">     calling any functions that modify the buffer. */</span>
  evbuffer_reserve_space(buf, 1024, v, 2);
  evbuffer_add(buf, <span style="color:#a31515">&#34;X&#34;</span>, 1);
  <span style="color:#008000">/* WRONG: This next line won&#39;t work if evbuffer_add needed to rearrange
</span><span style="color:#008000">     the buffer&#39;s contents.  It might even crash your program. Instead,
</span><span style="color:#008000">     you add the data before calling evbuffer_reserve_space. */</span>
  memset(v[0].iov_base, <span style="color:#a31515">&#39;Y&#39;</span>, v[0].iov_len-1);
  evbuffer_commit_space(buf, v, 1);
}

{
  <span style="color:#008000">/* Do not modify the iov_base pointers. */</span>
  <span style="color:#00f">const</span> <span style="color:#2b91af">char</span> *data = <span style="color:#a31515">&#34;Here is some data&#34;</span>;
  evbuffer_reserve_space(buf, strlen(data), v, 1);
  <span style="color:#008000">/* WRONG: The next line will not do what you want.  Instead, you
</span><span style="color:#008000">     should _copy_ the contents of data into v[0].iov_base. */</span>
  v[0].iov_base = (<span style="color:#2b91af">char</span>*) data;
  v[0].iov_len = strlen(data);
  <span style="color:#008000">/* In this case, evbuffer_commit_space might give an error if you&#39;re
</span><span style="color:#008000">     lucky */</span>
  evbuffer_commit_space(buf, v, 1);
}
</code></pre></div><h4 id="evbuffer与网路io">evbuffer与网路IO</h4>
<p>libevent中evbuffer最常见用例是网络IO，在evbuffer上的网络IO的接口是：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#2b91af">int</span> evbuffer_write(<span style="color:#00f">struct</span> <span style="color:#2b91af">evbuffer</span> *buffer, evutil_socket_t fd);
<span style="color:#2b91af">int</span> evbuffer_write_atmost(<span style="color:#00f">struct</span> <span style="color:#2b91af">evbuffer</span> *buffer, evutil_socket_t fd,
        ev_ssize_t howmuch);
<span style="color:#2b91af">int</span> evbuffer_read(<span style="color:#00f">struct</span> <span style="color:#2b91af">evbuffer</span> *buffer, evutil_socket_t fd, <span style="color:#2b91af">int</span> howmuch);
</code></pre></div><p><code>evbuffer_read()</code>函数在指定的fd上读取<code>howmuch</code>字节的数据到buffer的尾部，如果成功的话，返回读取的字节数，如果遇到EOF返回0，如果遇到错误的话，返回-1。请注意，该错误可能表明非阻塞操作不会成功，你可能需要检查<code>EAGAIN</code>的错误码（在windows上位WSAEWOULDBLOCK），如果<code>howmuch</code>是负值，<code>evbuffer_read()</code>函数将自己猜测需要读取多少数据。</p>
<p><code>evbuffer_write_atmost()</code>函数尝试从buffer的头部，取出<code>howmuch</code>字节长度的数据，写入fd，在成功时返回实际写入的字节数，在失败时返回-1。和<code>evbuffer_read()</code>函数一样，你需要检查检查错误代码以检查错误是否真实，或者只是表示无法立即完成非阻塞IO，如果<code>howmuch</code>传入了一个负值，则尝试写入整个buffer。</p>
<p>调用<code>evbuffer_write()</code>函数和调用<code>evbuffer_write_atmost()</code>函数时以负值传入howmuch，效果是一样的，它尽可能多的写入数据。</p>
<p>在unix上，这些函数在任何支持读写的文件描述符上都可以工作。在Windows上，仅仅支持套接字。</p>
<p>请注意，当你使用bufferevent的时候，不要调用这些IO函数，bufferevent会自动帮你做这些。</p>
<h4 id="evbuffer和回调">evbuffer和回调</h4>



                </div>

                
            </div>
        </div>
    </div>
</div>

<section id="comments">
    <div class="py-3 content">
        <div class="container">
            <div class="row justify-content-center">
                <div class="col-sm-12 col-lg-8">
                    <div class="comments">
                        <script src="https://utteranc.es/client.js" repo=""
                            issue-term="pathname" label="comment" theme="github-light" crossorigin="anonymous" async>
                            </script>
                    </div>
                </div>
            </div>
        </div>
    </div>
</section>



    

    
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/highlight.min.js" integrity="sha512-TDKKr+IvoqZnPzc3l35hdjpHD0m+b2EC2SrLEgKDRWpxf2rFCxemkgvJ5kfU48ip+Y+m2XVKyOCD85ybtlZDmw==" crossorigin="anonymous"></script>
        
            <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/languages/r.min.js" defer></script>
        
            <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/languages/python.min.js" defer></script>
        
            <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/languages/stan.min.js" defer></script>
        
        <script>
            window.addEventListener('load', function() {
                hljs.initHighlighting();
            }, true);
        </script>
    

    

    
    
        
<script src="https://guangxuanliu.github.io/js/math-code.js"></script>
<script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>


    
</body>

</html>
