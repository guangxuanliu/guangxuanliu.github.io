<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blog on 刘光轩的个人博客</title>
    <link>https://guangxuanliu.github.io/blog/</link>
    <description>Recent content in Blog on 刘光轩的个人博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sun, 05 Sep 2021 18:30:48 +0800</lastBuildDate><atom:link href="https://guangxuanliu.github.io/blog/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>可移植的工具函数</title>
      <link>https://guangxuanliu.github.io/blog/%E5%8F%AF%E7%A7%BB%E6%A4%8D%E7%9A%84%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sun, 05 Sep 2021 18:30:48 +0800</pubDate>
      
      <guid>https://guangxuanliu.github.io/blog/%E5%8F%AF%E7%A7%BB%E6%A4%8D%E7%9A%84%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0/</guid>
      <description>Libevent 的辅助函数和类型 &amp;lt;event2/util.h&amp;gt;头文件定义了许多函数，您可能会发现这些函数对使用 Libevent 实现可移植应用程序很有帮助。 libevent 在内部使用这些类型和函数。
基本类型 evutil_socket_t
在除了Windows之外的大部分地方，socket是一个int值，操作系统按数字的顺序处理它们。但是在Windows上，socket的类型为SOCKET，这是一个类似指针的操作系统句柄，并且你接收到它们的顺序是未定义的。我们将 evutil_socket_t 类型定义为一个整数，它可以保存 socket() 或 accept() 的输出，而不会在 Windows 上指针截断的风险。
#ifdef WIN32 #define evutil_socket_t intptr_t #else #define evutil_socket_t int #endif 标准整数类型
在较古老的系统上，没有C99的stdint.h头文件，为了应对这种情况，libevent定义了自己版本的特定位宽的整数。
   Type Width Signed Maximum Minimum     ev_uint64_t 64 No EV_UINT64_MAX 0   ev_int64_t 64 Yes EV_INT64_MAX EV_INT64_MIN   ev_uint32_t 32 No EV_UINT32_MAX 0   ev_int32_t 32 Yes EV_INT32_MAX EV_INT32_MIN   ev_uint16_t 16 No EV_UINT16_MAX 0   ev_int16_t 16 Yes EV_INT16_MAX EV_INT16_MIN   ev_uint8_t 8 No EV_UINT8_MAX 0   ev_int8_t 8 Yes EV_INT8_MAX EV_INT8_MIN    与 C99 标准一样，每种类型都具有指定的宽度（以位为单位）。</description>
    </item>
    
    <item>
      <title>Event</title>
      <link>https://guangxuanliu.github.io/blog/event/</link>
      <pubDate>Sat, 04 Sep 2021 20:17:14 +0800</pubDate>
      
      <guid>https://guangxuanliu.github.io/blog/event/</guid>
      <description>事件 event是libevent的基本操作单元，每一个event代表一系列条件的集合，包括：
 一个文件描述符准备好了读、写 一个文件描述符准备好了读、写（仅限于边缘触发） 超时到期 发生了信号 用户触发的事件  events拥有类似的生命周期。当你调用libevent的函数设置了一个event，并且将它关联到一个event_base，它的状态是initialized，在此时，你可以将它add进event_base，此时它的状态变为pending，当触发条件的事件发生时（比如，文件描述符状态改变或者超时到期），它的状态会变为active，此时用户提供的回调函数将会被调用，如果event被设置为persistent，它仍然保持pending状态，如果不是persistent的，当回调函数结束后，将不再是pending状态，你可以将pending 的event删除，使其变为non-pending状态，你可以将non-pending状态的event调用add使其变为pending状态。
构造event对象 调用event_new()创建一个新的event。
#define EV_TIMEOUT 0x01 #define EV_READ 0x02 #define EV_WRITE 0x04 #define EV_SIGNAL 0x08 #define EV_PERSIST 0x10 #define EV_ET 0x20  typedef void (*event_callback_fn)(evutil_socket_t, short, void *); struct event *event_new(struct event_base *base, evutil_socket_t fd, short what, event_callback_fn cb, void *arg); void event_free(struct event *event); event_new()使用指定的event_base分配并构造一个新的event，what参数是上面列举的一些标志位（具体语义将在下面描述），如果fd非负，我们将监控此fd的读写事件，当event变为active，libevent会调用cb回调函数，并传递参数：
 fd，文件描述符 bitfield，代表触发的事件的位集合 args，构造事件时指定的参数  当发生内部错误或参数无效时，返回NULL。
所有新创建的事件均为initialized，并且是non-pending状态，可以调用event_add()函数使其变为pending状态。
可以调用event_free()函数来释放一个event，当event处于pengding或者active状态时调用该函数是安全的。
#include &amp;lt;event2/event.h&amp;gt; void cb_func(evutil_socket_t fd, short what, void *arg) { const char *data = arg; printf(&amp;#34;Got an event on socket %d:%s%s%s%s [%s]&amp;#34;, (int) fd, (what&amp;amp;EV_TIMEOUT) ?</description>
    </item>
    
    <item>
      <title>运行event_loop</title>
      <link>https://guangxuanliu.github.io/blog/%E8%BF%90%E8%A1%8Cevent_loop/</link>
      <pubDate>Sat, 04 Sep 2021 17:36:09 +0800</pubDate>
      
      <guid>https://guangxuanliu.github.io/blog/%E8%BF%90%E8%A1%8Cevent_loop/</guid>
      <description>运行事件循环 一旦你在event_base上注册了一些events（下一章讲述如何创建并且注册events），你会想让libevent等待events并且通知你。
#define EVLOOP_ONCE 0x01 #define EVLOOP_NONBLOCK 0x02 #define EVLOOP_NO_EXIT_ON_EMPTY 0x04  int event_base_loop(struct event_base *base, int flags); 默认的，event_base_loop()函数运行event_base直到没有events在上面注册。当开始运行循环时，它不断的检测是否有events已经触发（例如，读取事件的文件描述符准备好读取，超时事件的超时到期），如果一旦发生，它把events标记为active，并且运行他们。
你可以给event_base_loop传递flags参数来改变默认的行为，如果设置了EVLOOP_ONCE，循环会等待直到有events变为active，然后运行它们，然后退出。如果设置了EVLOOP_NONBLOCK，循环不会等待events触发，它只会立即检测events是否准备好触发，如果是，则运行它们的回调。
一般地，如果没有pending或者active的events，循环会尽快退出。你可以设置EVLOOP_NO_EXIT_ON_EMPTY标志位来改变这一行为，比如，你准备在其它线程添加events，如果你设置了此标志位，循环会一直运行，直到event_base_loopbreak()、event_base_loopexit()被调用，或者遇到了错误。
当结束时，event_base_loop()返回0代表正常退出，返回-1代表后端有未处理的错误，返回1代表没有更多pending或者active的events。
为了帮助理解，下面是一段event_base_loop()的伪代码
while (any events are registered with the loop, or EVLOOP_NO_EXIT_ON_EMPTY was set) { if (EVLOOP_NONBLOCK was set, or any events are already active) If any registered events have triggered, mark them active. else Wait until at least one event has triggered, and mark it active. for (p = 0; p &amp;lt; n_priorities; ++p) { if (any event with priority of p is active) { Run all active events with priority of p.</description>
    </item>
    
    <item>
      <title>设置event_base</title>
      <link>https://guangxuanliu.github.io/blog/%E8%AE%BE%E7%BD%AEevent_base/</link>
      <pubDate>Fri, 27 Aug 2021 22:34:48 +0800</pubDate>
      
      <guid>https://guangxuanliu.github.io/blog/%E8%AE%BE%E7%BD%AEevent_base/</guid>
      <description>创建event_base 在你使用libevent的函数之前，你应该先创建一个或多个event_base结构，每一个event_base拥有event集合，并且轮询它们看哪个处于active状态。
如果event_base设置为使用锁，那么在多线程中使用是安全的，但是只能在一个线程中循环，如果你想在多个线程中轮询IO，你需要为每个线程分配一个event_base。
以后的libevent版本可能会支持event_base在多个线程中轮询。
每个event_base都有一个后端方法，来决定哪个event已经准备好了，方法如下：
 select poll epoll kqueue devpoll evport win32  使用者可以使用环境变量来禁用指定的方法，如果你想禁用kqueue方法，你可以设置EVENT_NOKQUEUE 环境变量。如果你想在你的程序中关闭某个方法，请参考下面的event_config_avoid_method方法。
默认的event_base event_base_new函数检测环境变量，以默认的参数设置创建并返回了event_base的指针，返回NULL代表出错。
他总是在系统中选择一个最快的方法。
struct event_base *event_base_new(void); 对大多数程序而言，这已经足够了。
event_base_new()函数在&amp;lt;event2/event.h&amp;gt;中声明。它首次出现在Libevent 1.4.3中。
设置更复杂的event_base 如果你想对event_base做更多的控制，你可以使用event_config，event_config是一个对用户不透明的结构，里面保存着你的偏好信息，当你创建event_base的时候，你可以使用event_base_new_with_config函数传入一个event_config参数。
struct event_config *event_config_new(void); struct event_base *event_base_new_with_config(const struct event_config *cfg); void event_config_free(struct event_config *cfg); 当你需要一个event_base的时候，首先调用event_config_new来创建一个event_config，然后调用其它的函数来设置event_config，最后调用event_base_new_with_config函数来得到一个event_base，当你完成所有操作后，调用event_config_free来释放event_config。
int event_config_avoid_method(struct event_config *cfg, const char *method); enum event_method_feature { EV_FEATURE_ET = 0x01, EV_FEATURE_O1 = 0x02, EV_FEATURE_FDS = 0x04, }; int event_config_require_features(struct event_config *cfg, enum event_method_feature feature); enum event_base_config_flag { EVENT_BASE_FLAG_NOLOCK = 0x01, EVENT_BASE_FLAG_IGNORE_ENV = 0x02, EVENT_BASE_FLAG_STARTUP_IOCP = 0x04, EVENT_BASE_FLAG_NO_CACHE_TIME = 0x08, EVENT_BASE_FLAG_EPOLL_USE_CHANGELIST = 0x10, EVENT_BASE_FLAG_PRECISE_TIMER = 0x20 }; int event_config_set_flag(struct event_config *cfg, enum event_base_config_flag flag); 调用event_config_avoid_method 方法告诉libevent不要使用后端的某个方法，event_config_require_feature告诉libevent不要选用不支持某些特性的方法，event_config_set_flag方法告诉libevent在构造event_base的时候设置某些标志位。</description>
    </item>
    
    <item>
      <title>设置libevent</title>
      <link>https://guangxuanliu.github.io/blog/%E8%AE%BE%E7%BD%AElibevent/</link>
      <pubDate>Wed, 25 Aug 2021 21:41:15 +0800</pubDate>
      
      <guid>https://guangxuanliu.github.io/blog/%E8%AE%BE%E7%BD%AElibevent/</guid>
      <description>设置libevent libevent有一些全局的设置会影响整个libevent库。你必须在调用库的任何函数之前进行设置，否则会导致libevent处于不一致的状态。
记录日志 libevent可以记录内部的错误和警告，如果编译时支持日志记录，它还会记录调试信息。默认情况下，这些信息被写入stderr，你可以提供自己的日志函数来覆盖这些行为。
#define EVENT_LOG_DEBUG 0 #define EVENT_LOG_MSG 1 #define EVENT_LOG_WARN 2 #define EVENT_LOG_ERR 3  /* Deprecated; see note at the end of this section */ #define _EVENT_LOG_DEBUG EVENT_LOG_DEBUG #define _EVENT_LOG_MSG EVENT_LOG_MSG #define _EVENT_LOG_WARN EVENT_LOG_WARN #define _EVENT_LOG_ERR EVENT_LOG_ERR  typedef void (*event_log_cb)(int severity, const char *msg); void event_set_log_callback(event_log_cb cb); 你可以写一个符合event_log_cb签名的函数，然后传递给event_set_log_callback来重写libevent默认的日志行为。当libevent需要写日志的时候，它会传递给你提供的函数。你可以调用event_set_log_callback，并且传递NULL参数来恢复libevent默认的日志行为。
#include &amp;lt;event2/event.h&amp;gt;#include &amp;lt;stdio.h&amp;gt; static void discard_cb(int severity, const char *msg) { /* This callback does nothing. */ } static FILE *logfile = NULL; static void write_to_file_cb(int severity, const char *msg) { const char *s; if (!</description>
    </item>
    
    <item>
      <title>前言</title>
      <link>https://guangxuanliu.github.io/blog/%E5%89%8D%E8%A8%80/</link>
      <pubDate>Wed, 25 Aug 2021 20:45:11 +0800</pubDate>
      
      <guid>https://guangxuanliu.github.io/blog/%E5%89%8D%E8%A8%80/</guid>
      <description>从一万英尺外看libevent libevent是一个可以写快速、可移植、非阻塞的网络IO库，设计目标为：
  可移植性
一个用libevent写的程序可以跨所有libevent支持的平台，即使是没有高效的方式实现非阻塞IO，libevent也支持普通的方式，以便你的程序在受限的环境中运行。
  速度
libevent尝试在每个平台上用最快的非阻塞IO实现，而且并不会为此带来额外的开销。
  便利
只要有可能，使用libevent编写的程序自然是稳定的，可移植的。
  libevent划分为以下组件：
  evutil
为跨平台抽象出来的通用工具函数。
  event和event_base
这是Libevent的核心。它为各种特定于平台的、基于事件的非阻塞 IO 后端提供抽象 API。它可以让您知道socket何时准备好读取或写入、执行基本超时功能以及检测操作系统信号。
  bufferevent
这些函数为libevent基于事件的核心提供了更便利的封装接口，它让应用程序对缓冲区进行读取和写入，而不是通知您socket可以读取，让你知道IO何时实际发生。
  evbuffer
该模块为bufferevents的底层缓冲实现，提供了高效便利的访问。
  evhttp
一个简单的HTTP客户端/服务端实现
  evdns
一个简单的dns客户端/服务端实现
  evrpc
一个简单的RPC实现
  库 当编译libevent的时候，默认安装以下库：
  libevent_core
所有核心事件、缓冲区功能。这个库包含了event_base、evbuffer、bufferevent和工具函数。
  libevent_extra
一些你可能需要，也可能不需要的基于特定协议的功能，包括HTTP、DNS和RPC。
  libevent
因为历史原因而存在，包含了libevent_core和libevent_extra，你不应该再使用这个库，在未来可能会取消这个库。
  libevent_pthreads
基于pthreads的线程、锁的可移植实现。它独立于libevent_core，如果你不需要以多线程的方式使用libevent的话，就不需要链接此库。
  libevent_openssl</description>
    </item>
    
    <item>
      <title>异步IO简介</title>
      <link>https://guangxuanliu.github.io/blog/%E5%BC%82%E6%AD%A5io%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Wed, 25 Aug 2021 20:29:26 +0800</pubDate>
      
      <guid>https://guangxuanliu.github.io/blog/%E5%BC%82%E6%AD%A5io%E7%AE%80%E4%BB%8B/</guid>
      <description>异步IO简介 大多数编程初学者使用的是阻塞的IO函数调用，也称为同步IO，当你调用它的时候，除非函数操作完成或者函数超时然后网络栈放弃的时候才会返回。举个例子，当你在TCP连接上调用connect()的时候，操作系统发送一个SYN数据包至对方主机，除非接收到了对方主机返回的SYN，ACK数据包才会返回至你的代码控制流程，或者是超时了，系统决定放弃的时候也会返回。
下面是一个用阻塞网络编程的小例子，它建立了一个到www.google.com的连接，发送了一个http请求，并输出结果至stdout。
/* For sockaddr_in */ #include &amp;lt;netinet/in.h&amp;gt;/* For socket functions */ #include &amp;lt;sys/socket.h&amp;gt;/* For gethostbyname */ #include &amp;lt;netdb.h&amp;gt; #include &amp;lt;unistd.h&amp;gt;#include &amp;lt;string.h&amp;gt;#include &amp;lt;stdio.h&amp;gt; int main(int c, char **v) { const char query[] = &amp;#34;GET / HTTP/1.0\r\n&amp;#34; &amp;#34;Host: www.google.com\r\n&amp;#34; &amp;#34;\r\n&amp;#34;; const char hostname[] = &amp;#34;www.google.com&amp;#34;; struct sockaddr_in sin; struct hostent *h; const char *cp; int fd; ssize_t n_written, remaining; char buf[1024]; /* Look up the IP address for the hostname. Watch out; this isn&amp;#39;t threadsafe on most platforms.</description>
    </item>
    
    <item>
      <title>关于这篇文档</title>
      <link>https://guangxuanliu.github.io/blog/%E5%85%B3%E4%BA%8E%E8%BF%99%E7%AF%87%E6%96%87%E6%A1%A3/</link>
      <pubDate>Mon, 23 Aug 2021 22:01:43 +0800</pubDate>
      
      <guid>https://guangxuanliu.github.io/blog/%E5%85%B3%E4%BA%8E%E8%BF%99%E7%AF%87%E6%96%87%E6%A1%A3/</guid>
      <description>这篇文档会教你如何使用libevent2.0(或者更新的版本)来写快速的、可移植的网络编程，假设你：
 有C语言的编程基础 知道C语言网络编程调用（socket()，connect()，等等）。  </description>
    </item>
    
    <item>
      <title>Libevent编程手册</title>
      <link>https://guangxuanliu.github.io/blog/libevent%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/</link>
      <pubDate>Sun, 22 Aug 2021 22:38:01 +0800</pubDate>
      
      <guid>https://guangxuanliu.github.io/blog/libevent%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/</guid>
      <description>了解libevent   关于这篇文档
  异步IO简介
  libevent参考手册   前言
  设置libevent
  设置event_base
  运行event_loop
  事件
  可移植的工具函数
  Bufferevents：概念与基础
  Bufferevents：高级主题
  Evbuffers：缓冲IO的功能
  Connection Listeners：接收TCP连接
  DNS
  本文翻译自英文版教程，因为本人水平有限，所以翻译的过程中难免有些地方措辞不当，表达不出原作者的意思，还请读者斧正。
原教程链接：http://www.wangafu.net/~nickm/libevent-book/</description>
    </item>
    
    <item>
      <title>建立博客的初衷</title>
      <link>https://guangxuanliu.github.io/blog/1.%E5%BB%BA%E7%AB%8B%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%88%9D%E8%A1%B7/</link>
      <pubDate>Thu, 27 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://guangxuanliu.github.io/blog/1.%E5%BB%BA%E7%AB%8B%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%88%9D%E8%A1%B7/</guid>
      <description>大学时，想搭一个自己的博客。想着自己技术不怎么样，所以一直搁置着。
毕业后前几年，想搭一个自己的博客。也尝试用django搭建过一个博客，放在了vps上，但是也没有坚持下来。
现在又重新搭建了博客，总结了一下原因：
 想训练一下自己的文字表达能力。表达能力一向偏弱，有时候词不达意，特别是前段时间写项目文档的时候，脑子里的词汇有点儿捉襟见肘。 想强迫自己系统的学习知识。有很多的知识只是浅尝辄止，知道一点皮毛，所以过了一段时间就会忘记。如果强迫自己写博客，要想完整的表达出来，必须在头脑中对这个知识认知非常清晰。 想为以后积累些文字材料。每次面试的时候，都会感觉有劲使不出，觉得面试官并没有了解到自己所会的东西。想用一些文字的材料对自己的技术加以佐证。  不管出于以上的哪一点原因，都希望这次自己能坚持下去。</description>
    </item>
    
  </channel>
</rss>
