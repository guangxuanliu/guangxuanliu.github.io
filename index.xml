<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>刘光轩的个人博客</title>
    <link>https://guangxuanliu.github.io/</link>
    <description>Recent content on 刘光轩的个人博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Wed, 25 Aug 2021 20:45:11 +0800</lastBuildDate><atom:link href="https://guangxuanliu.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>前言</title>
      <link>https://guangxuanliu.github.io/blog/%E5%89%8D%E8%A8%80/</link>
      <pubDate>Wed, 25 Aug 2021 20:45:11 +0800</pubDate>
      
      <guid>https://guangxuanliu.github.io/blog/%E5%89%8D%E8%A8%80/</guid>
      <description>从一万英尺外看libevent libevent是一个可以写快速、可移植、非阻塞的网络IO库，设计目标为：
  可移植性
一个用libevent写的程序可以跨所有libevent支持的平台，即使是没有高效的方式实现非阻塞IO，libevent也支持普通的方式，以便你的程序在受限的环境中运行。
  速度
libevent尝试在每个平台上用最快的非阻塞IO实现，而且并不会为此带来额外的开销。
  便利
只要有可能，使用libevent编写的程序自然是稳定的，可移植的。
  libevent划分为以下组件：
  evutil
为跨平台抽象出来的通用工具函数。
  event和event_base
这是Libevent的核心。它为各种特定于平台的、基于事件的非阻塞 IO 后端提供抽象 API。它可以让您知道socket何时准备好读取或写入、执行基本超时功能以及检测操作系统信号。
  bufferevent
这些函数为libevent基于事件的核心提供了更便利的封装接口，它让应用程序对缓冲区进行读取和写入，而不是通知您socket可以读取，让你知道IO何时实际发生。
  evbuffer
该模块为bufferevents的底层缓冲实现，提供了高效便利的访问。
  evhttp
一个简单的HTTP客户端/服务端实现
  evdns
一个简单的dns客户端/服务端实现
  evrpc
一个简单的RPC实现
  库 当编译libevent的时候，默认安装以下库：
  libevent_core
所有核心事件、缓冲区功能。这个库包含了event_base、evbuffer、bufferevent和工具函数。
  libevent_extra
一些你可能需要，也可能不需要的基于特定协议的功能，包括HTTP、DNS和RPC。
  libevent
因为历史原因而存在，包含了libevent_core和libevent_extra，你不应该再使用这个库，在未来可能会取消这个库。
  libevent_pthreads
基于pthreads的线程、锁的可移植实现。它独立于libevent_core，如果你不需要以多线程的方式使用libevent的话，就不需要链接此库。
  libevent_openssl</description>
    </item>
    
    <item>
      <title>异步IO简介</title>
      <link>https://guangxuanliu.github.io/blog/%E5%BC%82%E6%AD%A5io%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Wed, 25 Aug 2021 20:29:26 +0800</pubDate>
      
      <guid>https://guangxuanliu.github.io/blog/%E5%BC%82%E6%AD%A5io%E7%AE%80%E4%BB%8B/</guid>
      <description>异步IO简介 大多数编程初学者使用的是阻塞的IO函数调用，也称为同步IO，当你调用它的时候，除非函数操作完成或者函数超时然后网络栈放弃的时候才会返回。举个例子，当你在TCP连接上调用connect()的时候，操作系统发送一个SYN数据包至对方主机，除非接收到了对方主机返回的SYN，ACK数据包才会返回至你的代码控制流程，或者是超时了，系统决定放弃的时候也会返回。
下面是一个用阻塞网络编程的小例子，它建立了一个到www.google.com的连接，发送了一个http请求，并输出结果至stdout。
/* For sockaddr_in */ #include &amp;lt;netinet/in.h&amp;gt;/* For socket functions */ #include &amp;lt;sys/socket.h&amp;gt;/* For gethostbyname */ #include &amp;lt;netdb.h&amp;gt; #include &amp;lt;unistd.h&amp;gt;#include &amp;lt;string.h&amp;gt;#include &amp;lt;stdio.h&amp;gt; int main(int c, char **v) { const char query[] = &amp;#34;GET / HTTP/1.0\r\n&amp;#34; &amp;#34;Host: www.google.com\r\n&amp;#34; &amp;#34;\r\n&amp;#34;; const char hostname[] = &amp;#34;www.google.com&amp;#34;; struct sockaddr_in sin; struct hostent *h; const char *cp; int fd; ssize_t n_written, remaining; char buf[1024]; /* Look up the IP address for the hostname. Watch out; this isn&amp;#39;t threadsafe on most platforms.</description>
    </item>
    
    <item>
      <title>关于这篇文档</title>
      <link>https://guangxuanliu.github.io/blog/%E5%85%B3%E4%BA%8E%E8%BF%99%E7%AF%87%E6%96%87%E6%A1%A3/</link>
      <pubDate>Mon, 23 Aug 2021 22:01:43 +0800</pubDate>
      
      <guid>https://guangxuanliu.github.io/blog/%E5%85%B3%E4%BA%8E%E8%BF%99%E7%AF%87%E6%96%87%E6%A1%A3/</guid>
      <description>这篇文档会教你如何使用libevent2.0(或者更新的版本)来写快速的、可移植的网络编程，假设你：
 有C语言的编程基础 知道C语言网络编程调用（socket()，connect()，等等）。  </description>
    </item>
    
    <item>
      <title>Libevent编程手册</title>
      <link>https://guangxuanliu.github.io/blog/libevent%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/</link>
      <pubDate>Sun, 22 Aug 2021 22:38:01 +0800</pubDate>
      
      <guid>https://guangxuanliu.github.io/blog/libevent%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/</guid>
      <description>了解libevent   关于这篇文档
  异步IO简介
  libevent参考手册   前言
  设置libevent
  设置event_base
  运行event_loop
  事件
  可移植的工具函数
  Bufferevents：概念与基础
  Bufferevents：高级主题
  Evbuffers：缓冲IO的功能
  Connection Listeners：接收TCP连接
  DNS
  本文翻译自英文版教程，因为本人水平有限，所以翻译的过程中难免有些地方措辞不当，表达不出原作者的意思，还请读者斧正。
原教程链接：http://www.wangafu.net/~nickm/libevent-book/</description>
    </item>
    
    <item>
      <title>关于我</title>
      <link>https://guangxuanliu.github.io/about/</link>
      <pubDate>Thu, 27 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://guangxuanliu.github.io/about/</guid>
      <description>学历  青岛农业大学 ，计算机科学与技术，学士，2011~2015  技术栈  C++，2019~至今； Qt，2017~2019； JavaScript，2015~2017；  联系方式  guangxuanliu@gmail.com  </description>
    </item>
    
    <item>
      <title>建立博客的初衷</title>
      <link>https://guangxuanliu.github.io/blog/1.%E5%BB%BA%E7%AB%8B%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%88%9D%E8%A1%B7/</link>
      <pubDate>Thu, 27 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://guangxuanliu.github.io/blog/1.%E5%BB%BA%E7%AB%8B%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%88%9D%E8%A1%B7/</guid>
      <description>大学时，想搭一个自己的博客。想着自己技术不怎么样，所以一直搁置着。
毕业后前几年，想搭一个自己的博客。也尝试用django搭建过一个博客，放在了vps上，但是也没有坚持下来。
现在又重新搭建了博客，总结了一下原因：
 想训练一下自己的文字表达能力。表达能力一向偏弱，有时候词不达意，特别是前段时间写项目文档的时候，脑子里的词汇有点儿捉襟见肘。 想强迫自己系统的学习知识。有很多的知识只是浅尝辄止，知道一点皮毛，所以过了一段时间就会忘记。如果强迫自己写博客，要想完整的表达出来，必须在头脑中对这个知识认知非常清晰。 想为以后积累些文字材料。每次面试的时候，都会感觉有劲使不出，觉得面试官并没有了解到自己所会的东西。想用一些文字的材料对自己的技术加以佐证。  不管出于以上的哪一点原因，都希望这次自己能坚持下去。</description>
    </item>
    
  </channel>
</rss>
