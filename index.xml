<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>刘光轩的个人博客</title>
    <link>https://guangxuanliu.github.io/</link>
    <description>Recent content on 刘光轩的个人博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 18 May 2022 18:21:36 +0800</lastBuildDate><atom:link href="https://guangxuanliu.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>About</title>
      <link>https://guangxuanliu.github.io/about/</link>
      <pubDate>Sun, 19 Sep 2021 19:35:52 +0800</pubDate>
      
      <guid>https://guangxuanliu.github.io/about/</guid>
      <description>一名C++程序员。可以通过guangxuanliu@gmail.com联系到我。</description>
    </item>
    
    <item>
      <title>PostgreSQL空间检索性能测试</title>
      <link>https://guangxuanliu.github.io/post/postgresql%E7%A9%BA%E9%97%B4%E6%A3%80%E7%B4%A2%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Wed, 18 May 2022 18:21:36 +0800</pubDate>
      
      <guid>https://guangxuanliu.github.io/post/postgresql%E7%A9%BA%E9%97%B4%E6%A3%80%E7%B4%A2%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/</guid>
      <description></description>
    </item>
    
    <item>
      <title>离线环境安装PostgreSQL、PostGIS</title>
      <link>https://guangxuanliu.github.io/post/%E7%A6%BB%E7%BA%BF%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85postgresqlpostgis/</link>
      <pubDate>Mon, 16 May 2022 19:21:36 +0800</pubDate>
      
      <guid>https://guangxuanliu.github.io/post/%E7%A6%BB%E7%BA%BF%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85postgresqlpostgis/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Python基础语法</title>
      <link>https://guangxuanliu.github.io/post/python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</link>
      <pubDate>Thu, 17 Feb 2022 21:41:40 +0800</pubDate>
      
      <guid>https://guangxuanliu.github.io/post/python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Reactor模式</title>
      <link>https://guangxuanliu.github.io/post/reactor%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sun, 23 Jan 2022 10:15:49 +0800</pubDate>
      
      <guid>https://guangxuanliu.github.io/post/reactor%E6%A8%A1%E5%BC%8F/</guid>
      <description></description>
    </item>
    
    <item>
      <title>CMake项目示例</title>
      <link>https://guangxuanliu.github.io/post/cmake%E9%A1%B9%E7%9B%AE%E7%A4%BA%E4%BE%8B/</link>
      <pubDate>Sun, 10 Oct 2021 20:28:02 +0800</pubDate>
      
      <guid>https://guangxuanliu.github.io/post/cmake%E9%A1%B9%E7%9B%AE%E7%A4%BA%E4%BE%8B/</guid>
      <description>前言 在学习CMake的过程中，深感CMake不仅仅是学习C++路上的一个构建工具，完全是一门独立的语言，所以抽出时间来学习了一下基本的用法。</description>
    </item>
    
    <item>
      <title>Evbuffers：缓冲IO的功能</title>
      <link>https://guangxuanliu.github.io/post/evbuffers%E7%BC%93%E5%86%B2io%E7%9A%84%E5%8A%9F%E8%83%BD/</link>
      <pubDate>Mon, 13 Sep 2021 20:30:35 +0800</pubDate>
      
      <guid>https://guangxuanliu.github.io/post/evbuffers%E7%BC%93%E5%86%B2io%E7%9A%84%E5%8A%9F%E8%83%BD/</guid>
      <description>Libevent 的 evbuffer 功能实现了一个字节队列，针对将数据添加到末尾和从前面删除数据进行了优化。 Evbuffers 通常用于执行缓冲网络 IO 的“缓冲”部分。它们不提供调度 IO 或在 IO</description>
    </item>
    
    <item>
      <title>Bufferevents：高级主题</title>
      <link>https://guangxuanliu.github.io/post/bufferevents%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98/</link>
      <pubDate>Sat, 11 Sep 2021 17:06:07 +0800</pubDate>
      
      <guid>https://guangxuanliu.github.io/post/bufferevents%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98/</guid>
      <description>这一章节讲述一些bufferevent的高级特性，对初学者来说并不是必须的。如果你刚刚学习如何使用bufferevent，可以跳过本章节。 成</description>
    </item>
    
    <item>
      <title>bufferevent：概念与基础</title>
      <link>https://guangxuanliu.github.io/post/bufferevents%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Sun, 05 Sep 2021 19:23:14 +0800</pubDate>
      
      <guid>https://guangxuanliu.github.io/post/bufferevents%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%9F%BA%E7%A1%80/</guid>
      <description>大多数时候，除了响应事件之外，应用程序还希望执行一些数据缓冲。例如，当我们想要写入数据时，通常的模式运行如下： 决定我们要向连接写入一些数据；</description>
    </item>
    
    <item>
      <title>可移植的工具函数</title>
      <link>https://guangxuanliu.github.io/post/%E5%8F%AF%E7%A7%BB%E6%A4%8D%E7%9A%84%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sun, 05 Sep 2021 18:30:48 +0800</pubDate>
      
      <guid>https://guangxuanliu.github.io/post/%E5%8F%AF%E7%A7%BB%E6%A4%8D%E7%9A%84%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0/</guid>
      <description>Libevent 的辅助函数和类型 &amp;lt;event2/util.h&amp;gt;头文件定义了许多函数，您可能会发现这些函数对使用 Libevent 实现可移植应用程序很有帮助。 libevent</description>
    </item>
    
    <item>
      <title>Event</title>
      <link>https://guangxuanliu.github.io/post/event/</link>
      <pubDate>Sat, 04 Sep 2021 20:17:14 +0800</pubDate>
      
      <guid>https://guangxuanliu.github.io/post/event/</guid>
      <description>事件 event是libevent的基本操作单元，每一个event代表一系列条件的集合，包括： 一个文件描述符准备好了读、写 一个文件描述符准备好</description>
    </item>
    
    <item>
      <title>运行event_loop</title>
      <link>https://guangxuanliu.github.io/post/%E8%BF%90%E8%A1%8Cevent_loop/</link>
      <pubDate>Sat, 04 Sep 2021 17:36:09 +0800</pubDate>
      
      <guid>https://guangxuanliu.github.io/post/%E8%BF%90%E8%A1%8Cevent_loop/</guid>
      <description>运行事件循环 一旦你在event_base上注册了一些events（下一章讲述如何创建并且注册events），你会想让libevent等待ev</description>
    </item>
    
    <item>
      <title>设置event_base</title>
      <link>https://guangxuanliu.github.io/post/%E8%AE%BE%E7%BD%AEevent_base/</link>
      <pubDate>Fri, 27 Aug 2021 22:34:48 +0800</pubDate>
      
      <guid>https://guangxuanliu.github.io/post/%E8%AE%BE%E7%BD%AEevent_base/</guid>
      <description>创建event_base 在你使用libevent的函数之前，你应该先创建一个或多个event_base结构，每一个event_base拥有e</description>
    </item>
    
    <item>
      <title>设置libevent</title>
      <link>https://guangxuanliu.github.io/post/%E8%AE%BE%E7%BD%AElibevent/</link>
      <pubDate>Wed, 25 Aug 2021 21:41:15 +0800</pubDate>
      
      <guid>https://guangxuanliu.github.io/post/%E8%AE%BE%E7%BD%AElibevent/</guid>
      <description>设置libevent libevent有一些全局的设置会影响整个libevent库。你必须在调用库的任何函数之前进行设置，否则会导致libev</description>
    </item>
    
    <item>
      <title>前言</title>
      <link>https://guangxuanliu.github.io/post/%E5%89%8D%E8%A8%80/</link>
      <pubDate>Wed, 25 Aug 2021 20:45:11 +0800</pubDate>
      
      <guid>https://guangxuanliu.github.io/post/%E5%89%8D%E8%A8%80/</guid>
      <description>从一万英尺外看libevent libevent是一个可以写快速、可移植、非阻塞的网络IO库，设计目标为： 可移植性 一个用libevent写的程</description>
    </item>
    
    <item>
      <title>异步IO简介</title>
      <link>https://guangxuanliu.github.io/post/%E5%BC%82%E6%AD%A5io%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Wed, 25 Aug 2021 20:29:26 +0800</pubDate>
      
      <guid>https://guangxuanliu.github.io/post/%E5%BC%82%E6%AD%A5io%E7%AE%80%E4%BB%8B/</guid>
      <description>异步IO简介 大多数编程初学者使用的是阻塞的IO函数调用，也称为同步IO，当你调用它的时候，除非函数操作完成或者函数超时然后网络栈放弃的时候才</description>
    </item>
    
    <item>
      <title>关于这篇文档</title>
      <link>https://guangxuanliu.github.io/post/%E5%85%B3%E4%BA%8E%E8%BF%99%E7%AF%87%E6%96%87%E6%A1%A3/</link>
      <pubDate>Mon, 23 Aug 2021 22:01:43 +0800</pubDate>
      
      <guid>https://guangxuanliu.github.io/post/%E5%85%B3%E4%BA%8E%E8%BF%99%E7%AF%87%E6%96%87%E6%A1%A3/</guid>
      <description>这篇文档会教你如何使用libevent2.0(或者更新的版本)来写快速的、可移植的网络编程，假设你： 有C语言的编程基础 知道C语言网络编程调用</description>
    </item>
    
    <item>
      <title>Libevent编程手册</title>
      <link>https://guangxuanliu.github.io/post/libevent%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/</link>
      <pubDate>Sun, 22 Aug 2021 22:38:01 +0800</pubDate>
      
      <guid>https://guangxuanliu.github.io/post/libevent%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/</guid>
      <description>了解libevent 关于这篇文档 异步IO简介 libevent参考手册 前言 设置libevent 设置event_base 运行event_loop</description>
    </item>
    
    <item>
      <title>建立博客的初衷</title>
      <link>https://guangxuanliu.github.io/post/1.%E5%BB%BA%E7%AB%8B%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%88%9D%E8%A1%B7/</link>
      <pubDate>Thu, 27 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://guangxuanliu.github.io/post/1.%E5%BB%BA%E7%AB%8B%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%88%9D%E8%A1%B7/</guid>
      <description>大学时，想搭一个自己的博客。想着自己技术不怎么样，所以一直搁置着。 毕业后前几年，想搭一个自己的博客。也尝试用django搭建过一个博客，放在</description>
    </item>
    
    <item>
      <title></title>
      <link>https://guangxuanliu.github.io/linux%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://guangxuanliu.github.io/linux%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7/</guid>
      <description>Linux中的信号 Linux中涉及到信号的知识，这个信号并非Qt中的信号与槽中的信号，更非手机的信号。而是常见的在shell终端中输入kill -9杀死一个进程发送的信号；调试进程崩溃产生的core文件，常见的SIGSEGV信号。
信号的概念 每个信号都有一个名字，这些名字都以3个字符SIG开头，例如SIGALRM是闹钟信号，由alarm函数设定的定时器超时后将产生此信号。SIGSEGV是因为进程引用了无效的内存所产生的信号，此信号的默认处理方式是终止进程，并生成core文件。
在shell中，输入kill -l命令查看所有的信号。在开发中，需要包含signal.h。
信号的产生 信号的产生有如下几种方式：
 由键盘按键触发。如 SIGINT：Ctrl + C，用来终止前台的一个进程; 硬件异常产生的信号：除数为0，无效的内存引用等。这些条件通常由硬件检测到，并通知内核。然后内核为该条件发生时正在运行的进程产生适当的信号； 进程调用kill函数可将信号发送至其他进程； 用户用kill命令可将信号发送至其他进程；如kill -9 $(pidof a.out)将信号SIGKILL信号发送至a.out的进程。 软件条件触发的信号，如SIGPIPE、SIGALARM。  当一个信号产生时，内核通常在进程中以某种形式设置一个标志。当对信号采取了这种动作时，我们称为向进程递送了一个信号。
常用的信号 列举一些日常开发或者使用Linux过程中常用的信号：
 SIGABRT：异常终止。调用abort函数时产生此信号，代表进程异常终止； SIGALRM：定时器超时。用alarm函数设置的定时器超时时，发出此信号； SIGCHLD：子进程状态改变。如调用fork函数之后，子进程结束，父进程会收到此信号； SIGINT：在终端中前台执行一个进程，要退出时，按下键盘上的Ctrl+C键，可以触发此信号； SIGQUIT：终端退出符。在终端中，按下键盘上的Ctrl+\键，可以触发此信号； SIGTERM：终止。在终端中，kill命令默认发送的就是这个信号； SIGKILL：终止。这是两个不能被捕获或忽略信号中的一个。它向系统管理员提供了一中可以杀死任一进程的可靠方法； SIGSTOP：作业控制信号的一个，停止一个进程。此信号是两个不能被捕获或忽略信号中的另一个； SIGTSTP：交互式停止信号。按下键盘上的Ctrl+Z键可以触发此信号，挂起前台进程。 SIGSEGV：无效内存引用。段违例（segmentation violation），进程崩溃多和此信号有关，会同时生成core文件，根据core文件可以查看崩溃的位置。 SIGPIPE：向已经终止的管道写。比较常见的场景是socket的tcp通信中，对方的socket已经关闭，但是己方还往里写，就会触发这个信号，一般在自己的通信库中需要设置此信号为忽略。  信号的处理方式  忽略此信号。大多数信号都可以用此方式处理，但是有两个信号不能忽略，SIGKILL和SIGSTOP，这两个信号向内核和root用户提供了使进程终止的可靠的方法。 捕获信号。需要设置捕获函数，具体捕获信号的方法参考下一节。 执行系统默认动作。大多数信号的默认动作为终止进程。  捕获信号 捕获信号有两种方式，signal函数和sigaction函数。使用方式及优缺点如下所述，开发过程中尽量使用sigaction函数。
  signal函数
signal函数接收两个参数，要处理的信号以及处理方式。处理方式参考上一节。
 优点：简单。 缺点：在不改变某一信号处理方式的情况下，不能确定该信号的处理方式。而且该函数的语义与实现有关，最好使用sigaction函数来代替该函数。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  #include &amp;lt;stdio.</description>
    </item>
    
  </channel>
</rss>
