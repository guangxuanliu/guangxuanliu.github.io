<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Evbuffers：缓冲IO的功能 - 刘光轩的个人博客</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Liu Guangxuan" /><meta name="description" content="Libevent 的 evbuffer 功能实现了一个字节队列，针对将数据添加到末尾和从前面删除数据进行了优化。 Evbuffers 通常用于执行缓冲网络 IO 的“缓冲”部分。它们不提供调度 IO 或在 IO" /><meta name="keywords" content="刘光轩, 刘光轩的个人博客, liuguangxuan" />






<meta name="generator" content="Hugo 0.83.1 with theme even" />


<link rel="canonical" href="https://guangxuanliu.github.io/post/evbuffers%E7%BC%93%E5%86%B2io%E7%9A%84%E5%8A%9F%E8%83%BD/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.b5a744db6de49a86cadafb3b70f555ab443f83c307a483402259e94726b045ff.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Evbuffers：缓冲IO的功能" />
<meta property="og:description" content="Libevent 的 evbuffer 功能实现了一个字节队列，针对将数据添加到末尾和从前面删除数据进行了优化。 Evbuffers 通常用于执行缓冲网络 IO 的“缓冲”部分。它们不提供调度 IO 或在 IO" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://guangxuanliu.github.io/post/evbuffers%E7%BC%93%E5%86%B2io%E7%9A%84%E5%8A%9F%E8%83%BD/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-09-13T20:30:35&#43;08:00" />
<meta property="article:modified_time" content="2021-09-13T20:30:35&#43;08:00" />

<meta itemprop="name" content="Evbuffers：缓冲IO的功能">
<meta itemprop="description" content="Libevent 的 evbuffer 功能实现了一个字节队列，针对将数据添加到末尾和从前面删除数据进行了优化。 Evbuffers 通常用于执行缓冲网络 IO 的“缓冲”部分。它们不提供调度 IO 或在 IO"><meta itemprop="datePublished" content="2021-09-13T20:30:35&#43;08:00" />
<meta itemprop="dateModified" content="2021-09-13T20:30:35&#43;08:00" />
<meta itemprop="wordCount" content="6647">
<meta itemprop="keywords" content="libevent," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Evbuffers：缓冲IO的功能"/>
<meta name="twitter:description" content="Libevent 的 evbuffer 功能实现了一个字节队列，针对将数据添加到末尾和从前面删除数据进行了优化。 Evbuffers 通常用于执行缓冲网络 IO 的“缓冲”部分。它们不提供调度 IO 或在 IO"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Liu&#39;s Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Liu&#39;s Blog</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Evbuffers：缓冲IO的功能</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-09-13 </span>
        <div class="post-category">
            <a href="/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"> 网络编程 </a>
            <a href="/categories/linux/"> Linux </a>
            </div>
          <span class="more-meta"> 约 6647 字 </span>
          <span class="more-meta"> 预计阅读 14 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li>
          <ul>
            <li></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>Libevent 的 <code>evbuffer</code> 功能实现了一个字节队列，针对将数据添加到末尾和从前面删除数据进行了优化。</p>
<p>Evbuffers 通常用于执行缓冲网络 IO 的“缓冲”部分。它们不提供调度 IO 或在 IO 准备好时触发 IO 的功能：这是 bufferevents 所做的功能。</p>
<p>除非特别说明，本章的所有函数声明在<code>event2/buffer.h</code>头文件中。</p>
<h4 id="创建或释放evbuffer">创建或释放evbuffer</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">struct</span> <span class="nc">evbuffer</span> <span class="o">*</span><span class="nf">evbuffer_new</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">evbuffer_free</span><span class="p">(</span><span class="k">struct</span> <span class="nc">evbuffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p><code>evbuffer_new()</code>分配内存并且返回一个新的空的evbuffer，<code>evbuffer_free()</code>释放并且清除evbuffer的内容。</p>
<h4 id="evbuffer与线程安全">evbuffer与线程安全</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">int</span> <span class="nf">evbuffer_enable_locking</span><span class="p">(</span><span class="k">struct</span> <span class="nc">evbuffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">lock</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">evbuffer_lock</span><span class="p">(</span><span class="k">struct</span> <span class="nc">evbuffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">evbuffer_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="nc">evbuffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>默认情况下，同时在多个线程中访问evbuffer并不是安全的。如果需要在多线程中访问，你需要在evbuffer上调用<code>evbuffer_enable_locking()</code>，如果<code>lock</code>参数为NULL，libevent使用使用<code>evthread_set_lock_creation_callback</code>函数的锁创建函数来分配一个新的锁。如果<code>lock</code>参数不为空的话，则用之作为锁。</p>
<p><code>evbuffer_lock()</code>和<code>evbuffer_unlock()</code>函数分别获取和释放锁。你可以使用它们来进行一系列的原子操作。如果evbuffer没有启用加锁，则这些函数调用无效。</p>
<p>（注意，单个操作无须调用<code>evbuffer_lock()</code>和<code>evbuffer_unlock()</code>，如果evbuffer启用了加锁，单个操作已经是原子的了。只有在多线程同时有多个操作的情况下手动锁定evbuffer。）</p>
<h4 id="检查evbuffer">检查evbuffer</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">size_t</span> <span class="nf">evbuffer_get_length</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="nc">evbuffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>该函数返回存储在evbuffer中的字节数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">size_t</span> <span class="nf">evbuffer_get_contiguous_space</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="nc">evbuffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>该函数返回evbuffer中前面连续的字节数。evbuffer的字节可能存储在多个分散的内存块中，这个函数返回第一个内存块中连续的字节数。</p>
<h4 id="向evbuffer添加数据">向evbuffer添加数据</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">int</span> <span class="nf">evbuffer_add</span><span class="p">(</span><span class="k">struct</span> <span class="nc">evbuffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">datlen</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>该函数将以data起始的datlen长度的数据添加到buf的尾部。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">int</span> <span class="nf">evbuffer_add_printf</span><span class="p">(</span><span class="k">struct</span> <span class="nc">evbuffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span>
<span class="kt">int</span> <span class="n">evbuffer_add_vprintf</span><span class="p">(</span><span class="k">struct</span> <span class="nc">evbuffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="n">va_list</span> <span class="n">ap</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>上述两个函数向buf的尾部添加格式化的数据，fmt参数及后续的参数同C函数的<code>printf</code>和<code>vprintf</code>，这两个函数均返回添加的字节数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">int</span> <span class="nf">evbuffer_expand</span><span class="p">(</span><span class="k">struct</span> <span class="nc">evbuffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">datlen</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>此函数修改缓冲区的最后一个内存块，或者新增一个内存块，使evbuffer不用再进行分配内存便可以存入datlen长度的数据。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/* Here are two ways to add &#34;Hello world 2.0.1&#34; to a buffer. */</span>
<span class="cm">/* Directly: */</span>
<span class="n">evbuffer_add</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&#34;Hello world 2.0.1&#34;</span><span class="p">,</span> <span class="mi">17</span><span class="p">);</span>

<span class="cm">/* Via printf: */</span>
<span class="n">evbuffer_add_printf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&#34;Hello %s %d.%d.%d&#34;</span><span class="p">,</span> <span class="s">&#34;world&#34;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="从一个evbuffer移动数据到另一个evbuffer">从一个evbuffer移动数据到另一个evbuffer</h4>
<p>为了提高效率，libevent优化了从一个evbuffer移动数据到另一个evbuffer的功能。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">int</span> <span class="nf">evbuffer_add_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="nc">evbuffer</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">evbuffer</span> <span class="o">*</span><span class="n">src</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">evbuffer_remove_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="nc">evbuffer</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">evbuffer</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span>
    <span class="n">size_t</span> <span class="n">datlen</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p><code>evbuffer_add_buffer()</code>函数把src中的所有数据移动到dst中。成功时返回0，失败时返回-1.</p>
<p><code>evbuffer_remove_buffer()</code>函数把src中datlen长度字节的数据移动到dst中，尽可能少的减少复制。如果src中的数据少于datlen，则将src中的数据全部移动到dst中。该函数返回移动的字节数。</p>
<h4 id="向evbuffer的头部添加数据">向evbuffer的头部添加数据</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">int</span> <span class="nf">evbuffer_prepend</span><span class="p">(</span><span class="k">struct</span> <span class="nc">evbuffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">size</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">evbuffer_prepend_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="nc">evbuffer</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">evbuffer</span><span class="o">*</span> <span class="n">src</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>这两个函数和<code>evbuffer_add()</code>、<code>evbuffer_add_buffer()</code>类似，不过这两个函数向evbuffer的头部添加数据。</p>
<h4 id="重新调整evbuffer的内部布局">重新调整evbuffer的内部布局</h4>
<p>有时你想要检查evbuffer的前N个字节的数据，并将其视为连续的字节数组。为了达到此目的，你首先要确保evbuffer的前端确实是连续的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">evbuffer_pullup</span><span class="p">(</span><span class="k">struct</span> <span class="nc">evbuffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">ev_ssize_t</span> <span class="n">size</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p><code>evbuffer_pullup()</code>函数线性化buf的前size字节，如果需要的话，进行数据的拷贝和移动以确保它们在同一块连续的内存块上。如果size参数为负数，此函数线性化整个buf，如果size大于buf的长度，则返回NULL。正常情况下，<code>evbuffer_pullup()</code>函数返回第一个字节的指针。</p>
<p>当给size指定很大的值的时候调用此函数，可能会很慢，因为可能需要拷贝整个缓冲区的内容。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="cp">#include</span> <span class="cpf">&lt;event2/buffer.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;event2/util.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">parse_socks4</span><span class="p">(</span><span class="k">struct</span> <span class="nc">evbuffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">ev_uint16_t</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="n">ev_uint32_t</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* Let&#39;s parse the start of a SOCKS4 request!  The format is easy:
</span><span class="cm">     * 1 byte of version, 1 byte of command, 2 bytes destport, 4 bytes of
</span><span class="cm">     * destip. */</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mem</span><span class="p">;</span>

    <span class="n">mem</span> <span class="o">=</span> <span class="n">evbuffer_pullup</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">mem</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* Not enough data in the buffer */</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">mem</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">4</span> <span class="o">||</span> <span class="n">mem</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* Unrecognized protocol or command */</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">mem</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">mem</span><span class="o">+</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
        <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="o">*</span><span class="n">port</span><span class="p">);</span>
        <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="o">*</span><span class="n">addr</span><span class="p">);</span>
        <span class="cm">/* Actually remove the data from the buffer now that we know we
</span><span class="cm">           like it. */</span>
        <span class="n">evbuffer_drain</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>注意：以<code>evbuffer_get_contiguous_space()</code>返回值为参数调用<code>evbuffer_pullup()</code>并不会导致任何数据的移动和拷贝。</p>
<h4 id="从evbuffer中移除数据">从evbuffer中移除数据</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="kt">int</span> <span class="nf">evbuffer_drain</span><span class="p">(</span><span class="k">struct</span> <span class="nc">evbuffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">len</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">evbuffer_remove</span><span class="p">(</span><span class="k">struct</span> <span class="nc">evbuffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">datlen</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p><code>evbuffer_remove()</code>函数拷贝datlen字节的数据值data中，并且移除原来的数据。如果可用的长度小于datlen，则此函数拷贝所有的字节。该函数失败时返回-1，成功时返回拷贝的字节数。</p>
<p><code>evbuffer_drain()</code>和<code>evbuffer_remove()</code>函数类似。但是它只是移除数据，并不进行拷贝。该函数在成功时返回0，失败时返回-1.</p>
<h4 id="从evbuffer中拷贝数据">从evbuffer中拷贝数据</h4>
<p>有时你只想从evbuffer的起始位置拷贝数据，但是并不想移除。例如，你只想看看是否到了一个完整的记录，而不想移除或者重新排列缓冲区。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">ev_ssize_t</span> <span class="nf">evbuffer_copyout</span><span class="p">(</span><span class="k">struct</span> <span class="nc">evbuffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">datlen</span><span class="p">);</span>
<span class="n">ev_ssize_t</span> <span class="nf">evbuffer_copyout_from</span><span class="p">(</span><span class="k">struct</span> <span class="nc">evbuffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
     <span class="k">const</span> <span class="k">struct</span> <span class="nc">evbuffer_ptr</span> <span class="o">*</span><span class="n">pos</span><span class="p">,</span>
     <span class="kt">void</span> <span class="o">*</span><span class="n">data_out</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">datlen</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p><code>evbuffer_copyout()</code>和<code>evbuffer_remove()</code>类似，但是并不从缓冲区中移除数据。他将datlen字节的数据拷贝到data所在的内存中，如果buf中长度小于datlen，该函数拷贝所有的字节数。该函数在成功时返回拷贝的字节数，在失败时返回-1.</p>
<p><code>evbuffer_copyout_from()</code>函数和<code>evbuffer_copyout()</code>函数类似，但是它不是从buf的起始位置拷贝数据，而是从pos开始的位置进行拷贝。有关<code>evbuffer_ptr</code>的更多信息，请参考“搜索evbuffer”小节。</p>
<p>如果从evbuffer中拷贝数据太慢了，请使用<code>evbuffer_peek()</code>函数代替。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;event2/buffer.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;event2/util.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">get_record</span><span class="p">(</span><span class="k">struct</span> <span class="nc">evbuffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">size_t</span> <span class="o">*</span><span class="n">size_out</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">record_out</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* Let&#39;s assume that we&#39;re speaking some protocol where records
</span><span class="cm">       contain a 4-byte size field in network order, followed by that
</span><span class="cm">       number of bytes.  We will return 1 and set the &#39;out&#39; fields if we
</span><span class="cm">       have a whole record, return 0 if the record isn&#39;t here yet, and
</span><span class="cm">       -1 on error.  */</span>
    <span class="n">size_t</span> <span class="n">buffer_len</span> <span class="o">=</span> <span class="n">evbuffer_get_length</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
    <span class="n">ev_uint32_t</span> <span class="n">record_len</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">record</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">buffer_len</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span>
       <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* The size field hasn&#39;t arrived. */</span>

   <span class="cm">/* We use evbuffer_copyout here so that the size field will stay on
</span><span class="cm">       the buffer for now. */</span>
    <span class="n">evbuffer_copyout</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">record_len</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
    <span class="cm">/* Convert len_buf into host order. */</span>
    <span class="n">record_len</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">record_len</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">buffer_len</span> <span class="o">&lt;</span> <span class="n">record_len</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* The record hasn&#39;t arrived */</span>

    <span class="cm">/* Okay, _now_ we can remove the record. */</span>
    <span class="n">record</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">record_len</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">record</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="n">evbuffer_drain</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
    <span class="n">evbuffer_remove</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">record</span><span class="p">,</span> <span class="n">record_len</span><span class="p">);</span>

    <span class="o">*</span><span class="n">record_out</span> <span class="o">=</span> <span class="n">record</span><span class="p">;</span>
    <span class="o">*</span><span class="n">size_out</span> <span class="o">=</span> <span class="n">record_len</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="面向行的输入">面向行的输入</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">enum</span> <span class="nc">evbuffer_eol_style</span> <span class="p">{</span>
        <span class="n">EVBUFFER_EOL_ANY</span><span class="p">,</span>
        <span class="n">EVBUFFER_EOL_CRLF</span><span class="p">,</span>
        <span class="n">EVBUFFER_EOL_CRLF_STRICT</span><span class="p">,</span>
        <span class="n">EVBUFFER_EOL_LF</span><span class="p">,</span>
        <span class="n">EVBUFFER_EOL_NUL</span>
<span class="p">};</span>
<span class="kt">char</span> <span class="o">*</span><span class="nf">evbuffer_readln</span><span class="p">(</span><span class="k">struct</span> <span class="nc">evbuffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="n">size_t</span> <span class="o">*</span><span class="n">n_read_out</span><span class="p">,</span>
    <span class="k">enum</span> <span class="nc">evbuffer_eol_style</span> <span class="n">eol_style</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>许多互联网协议使用了基于行的协议。<code>evbuffer_readln()</code>函数同evbuffer的头部提取一行，并且返回新的以NUL结尾的字符串。如果<code>n_read_out</code>非空，<code>*n_read_out</code>被设置为返回的字符串的长度。如果没有一整行可以读取，该函数返回NULL，行结束符不包括在返回的字符串中。</p>
<p>该函数理解4种类型的行结束符：</p>
<ul>
<li>
<p>EVBUFFER_EOL_LF</p>
<p>单个的回车符（\n，ASCII码为0x0A）</p>
</li>
<li>
<p>EVBUFFER_EOL_CRLF_STRICT</p>
<p>回车换行（\r\n，ASCII码为0x0D 0x0A）</p>
</li>
<li>
<p>EVBUFFER_EOL_CRLF</p>
<p>可选的回车，然后时换行（\r\n或者\n），这种格式在解析互联网协议的时候很有用，因为标准通常规定了\r\n为行结束符，但是有些非标准使用的是\n。</p>
</li>
<li>
<p>EVBUFFER_EOL_ANY</p>
<p>任意数量、任意序列的回车换行符，这种格式不太常用，主要是为了向后兼容</p>
</li>
<li>
<p>EVBUFFER_EOL_NUL</p>
<p>单字节的0，ASCII为NUL。</p>
</li>
</ul>
<p>注意：如果您使用 <code>event_set_mem_functions() </code>覆盖默认 <code>malloc</code>，则 <code>evbuffer_readln</code> 返回的字符串将由您指定的 <code>malloc-replacement </code>分配。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">char</span> <span class="o">*</span><span class="n">request_line</span><span class="p">;</span>
<span class="n">size_t</span> <span class="n">len</span><span class="p">;</span>

<span class="n">request_line</span> <span class="o">=</span> <span class="n">evbuffer_readln</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">,</span> <span class="n">EVBUFFER_EOL_CRLF</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">request_line</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* The first line has not arrived yet. */</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">request_line</span><span class="p">,</span> <span class="s">&#34;HTTP/1.0 &#34;</span><span class="p">,</span> <span class="mi">9</span><span class="p">))</span> <span class="p">{</span>
        <span class="cm">/* HTTP 1.0 detected ... */</span>
    <span class="p">}</span>
    <span class="n">free</span><span class="p">(</span><span class="n">request_line</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="搜索evbuffer">搜索evbuffer</h4>
<p><code>evbuffer_ptr</code> 结构指向 <code>evbuffer</code> 中的一个位置，并包含可用于遍历 <code>evbuffer</code> 的数据。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">struct</span> <span class="nc">evbuffer_ptr</span> <span class="p">{</span>
        <span class="n">ev_ssize_t</span> <span class="n">pos</span><span class="p">;</span>
        <span class="k">struct</span> <span class="p">{</span>
                <span class="cm">/* internal fields */</span>
        <span class="p">}</span> <span class="n">_internal</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p><code>pos</code>字段是唯一的公开字段，其余的字段使用者不应该调用，它代表着一个evbuffer从起始位置的偏移量。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="k">struct</span> <span class="nc">evbuffer_ptr</span> <span class="nf">evbuffer_search</span><span class="p">(</span><span class="k">struct</span> <span class="nc">evbuffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">what</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="nc">evbuffer_ptr</span> <span class="o">*</span><span class="n">start</span><span class="p">);</span>
<span class="k">struct</span> <span class="nc">evbuffer_ptr</span> <span class="nf">evbuffer_search_range</span><span class="p">(</span><span class="k">struct</span> <span class="nc">evbuffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">what</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="nc">evbuffer_ptr</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span>
    <span class="k">const</span> <span class="k">struct</span> <span class="nc">evbuffer_ptr</span> <span class="o">*</span><span class="n">end</span><span class="p">);</span>
<span class="k">struct</span> <span class="nc">evbuffer_ptr</span> <span class="nf">evbuffer_search_eol</span><span class="p">(</span><span class="k">struct</span> <span class="nc">evbuffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
    <span class="k">struct</span> <span class="nc">evbuffer_ptr</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="n">size_t</span> <span class="o">*</span><span class="n">eol_len_out</span><span class="p">,</span>
    <span class="k">enum</span> <span class="nc">evbuffer_eol_style</span> <span class="n">eol_style</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p><code>evbuffer_search()</code>函数在evbuffer中搜索长度为len的what字符串。如果找到了，则返回<code>evbuffer_ptr</code>，包含了字符串所在的位置，如果没找到的话，返回-1。如果指定了start参数，则从此start参数所在的位置开始搜索，否则从evbuffer的起始位置开始搜索。</p>
<p><code>evbuffer_search_range()</code>函数和<code>evbuffer_search()</code>一样，除了只搜索end之前的位置。</p>
<p><code>evbuffer_search_eol()</code>函数想<code>evbuffer_readln()</code>函数一样检测行结束符。但是并不拷贝行数据，仅仅返回<code>evbuffer_ptr</code>指向行结束符的起始位置，如果eol_len_out参数为非空，则将其设置为EOL字符串的长度。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">enum</span> <span class="nc">evbuffer_ptr_how</span> <span class="p">{</span>
        <span class="n">EVBUFFER_PTR_SET</span><span class="p">,</span>
        <span class="n">EVBUFFER_PTR_ADD</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">evbuffer_ptr_set</span><span class="p">(</span><span class="k">struct</span> <span class="nc">evbuffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">evbuffer_ptr</span> <span class="o">*</span><span class="n">pos</span><span class="p">,</span>
    <span class="n">size_t</span> <span class="n">position</span><span class="p">,</span> <span class="k">enum</span> <span class="nc">evbuffer_ptr_how</span> <span class="n">how</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p><code>evbuffer_ptr_set</code> 函数操作缓冲区内 <code>evbuffer_ptr pos</code> 的位置。如果是 <code>EVBUFFER_PTR_SET</code>，则指针移动到缓冲区内的绝对位置。如果是 <code>EVBUFFER_PTR_ADD</code>，则指针向前移动位置字节。此函数在成功时返回 0，在失败时返回 -1。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;event2/buffer.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cm">/* Count the total occurrences of &#39;str&#39; in &#39;buf&#39;. */</span>
<span class="kt">int</span> <span class="nf">count_instances</span><span class="p">(</span><span class="k">struct</span> <span class="nc">evbuffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">evbuffer_ptr</span> <span class="n">p</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">len</span><span class="p">)</span>
        <span class="cm">/* Don&#39;t try to count the occurrences of a 0-length string. */</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="n">evbuffer_ptr_set</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">EVBUFFER_PTR_SET</span><span class="p">);</span>

    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
         <span class="n">p</span> <span class="o">=</span> <span class="n">evbuffer_search</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>
         <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
             <span class="k">break</span><span class="p">;</span>
         <span class="n">total</span><span class="o">++</span><span class="p">;</span>
         <span class="n">evbuffer_ptr_set</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">EVBUFFER_PTR_ADD</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">total</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="检测数据而不复制数据">检测数据，而不复制数据</h4>
<p>有时你想读取数据，但是并不进行数据的读取（evbuffer_copy()），也不进行数据的重组（evbuffer_pullup()），有时你只想查看evbuffer中间的一些数据。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">struct</span> <span class="nc">evbuffer_iovec</span> <span class="p">{</span>
        <span class="kt">void</span> <span class="o">*</span><span class="n">iov_base</span><span class="p">;</span>
        <span class="n">size_t</span> <span class="n">iov_len</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">evbuffer_peek</span><span class="p">(</span><span class="k">struct</span> <span class="nc">evbuffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="n">ev_ssize_t</span> <span class="n">len</span><span class="p">,</span>
    <span class="k">struct</span> <span class="nc">evbuffer_ptr</span> <span class="o">*</span><span class="n">start_at</span><span class="p">,</span>
    <span class="k">struct</span> <span class="nc">evbuffer_iovec</span> <span class="o">*</span><span class="n">vec_out</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n_vec</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>当你调用此函数时，<code>vec_out</code>参数代表一个数组，<code>n_vec</code>代表数组中元素的个数。该函数填充此数组，使数组元素中的<code>iov_base</code>指向evbuffer中内存块的指针，<code>iov_len</code>代表内存块的长度。</p>
<p>如果<code>len</code>参数小于0，<code>evbuffer_peek()</code>尝试填充你提供的数组的所有元素。如果<code>len</code>参数不为0，则数组中元素所指向的内存块至少包含len字节。如果你提供了数组及长度字段，该函数返回所填充的数组的个数，否则返回需要的数组元素的个数。</p>
<p>当ptr参数为NULL时，<code>evbuffer_peek()</code>从buffer的起始位置开始遍历，否则从ptr指向的位置开始遍历。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="p">{</span>
    <span class="cm">/* Let&#39;s look at the first two chunks of buf, and write them to stderr. */</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">evbuffer_iovec</span> <span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">evbuffer_peek</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* There might be less than two chunks available. */</span>
        <span class="n">fwrite</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">iov_base</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">iov_len</span><span class="p">,</span> <span class="n">stderr</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="p">{</span>
    <span class="cm">/* Let&#39;s send the first 4906 bytes to stdout via write. */</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">evbuffer_iovec</span> <span class="o">*</span><span class="n">v</span><span class="p">;</span>
    <span class="n">size_t</span> <span class="n">written</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="cm">/* determine how many chunks we need. */</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">evbuffer_peek</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">4096</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="cm">/* Allocate space for the chunks.  This would be a good time to use
</span><span class="cm">       alloca() if you have it. */</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="nc">evbuffer_iovec</span><span class="p">)</span><span class="o">*</span><span class="n">n</span><span class="p">);</span>
    <span class="cm">/* Actually fill up v. */</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">evbuffer_peek</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">4096</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">iov_len</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">written</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="mi">4096</span><span class="p">)</span>
            <span class="n">len</span> <span class="o">=</span> <span class="mi">4096</span> <span class="o">-</span> <span class="n">written</span><span class="p">;</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">write</span><span class="p">(</span><span class="mi">1</span> <span class="cm">/* stdout */</span><span class="p">,</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">iov_base</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="cm">/* We keep track of the bytes written separately; if we don&#39;t,
</span><span class="cm">           we may write more than 4096 bytes if the last chunk puts
</span><span class="cm">           us over the limit. */</span>
        <span class="n">written</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">free</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
<span class="p">}</span>

<span class="p">{</span>
    <span class="cm">/* Let&#39;s get the first 16K of data after the first occurrence of the
</span><span class="cm">       string &#34;start\n&#34;, and pass it to a consume() function. */</span>
    <span class="k">struct</span> <span class="nc">evbuffer_ptr</span> <span class="n">ptr</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">evbuffer_iovec</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="n">s</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&#34;start</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">n_written</span><span class="p">;</span>

    <span class="n">ptr</span> <span class="o">=</span> <span class="n">evbuffer_search</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ptr</span><span class="p">.</span><span class="n">pos</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span> <span class="cm">/* no start string found. */</span>

    <span class="cm">/* Advance the pointer past the start string. */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">evbuffer_ptr_set</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptr</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">EVBUFFER_PTR_ADD</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span> <span class="cm">/* off the end of the string. */</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">n_written</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="o">*</span><span class="mi">1024</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* Peek at a single chunk. */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">evbuffer_peek</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptr</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="cm">/* Pass the data to some user-defined consume function */</span>
        <span class="n">consume</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">iov_base</span><span class="p">,</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">iov_len</span><span class="p">);</span>
        <span class="n">n_written</span> <span class="o">+=</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">iov_len</span><span class="p">;</span>

        <span class="cm">/* Advance the pointer so we see the next chunk next time. */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">evbuffer_ptr_set</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptr</span><span class="p">,</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">iov_len</span><span class="p">,</span> <span class="n">EVBUFFER_PTR_ADD</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>注意</strong></p>
<ul>
<li>修改<code>evbuffer_iovec</code>指向的数据将导致未定义的行为。</li>
<li>如果调用任何修改 evbuffer 的函数，则 <code>evbuffer_peek()</code> 产生的指针可能会变得无效。</li>
<li>如果evbuffer需要在多线程中使用，确保调用<code>evbuffer_peek()</code>函数之前先调用<code>evbuffer_lock()</code>，并在调用结束时调用<code>evbuffer_unlock()</code>。</li>
</ul>
<h4 id="向evbuffer中直接添加数据">向evbuffer中直接添加数据</h4>
<p>有时你想直接往evbuffer中直接添加数据，无需先将其写入字符数组，然后再调用<code>evbuffer_add()</code>进行拷贝。你可以调用一对高级的函数来达到此功能：</p>
<ul>
<li>evbuffer_reserve_space()</li>
<li>evbuffer_commit_space()</li>
</ul>
<p>就像<code>evbuffer_peek()</code>一样，这些函数使用<code>evbuffer_iovec</code>结构，来提供对evbuffer中的内存进行直接的访问。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">int</span> <span class="nf">evbuffer_reserve_space</span><span class="p">(</span><span class="k">struct</span> <span class="nc">evbuffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">ev_ssize_t</span> <span class="n">size</span><span class="p">,</span>
    <span class="k">struct</span> <span class="nc">evbuffer_iovec</span> <span class="o">*</span><span class="n">vec</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n_vecs</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">evbuffer_commit_space</span><span class="p">(</span><span class="k">struct</span> <span class="nc">evbuffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
    <span class="k">struct</span> <span class="nc">evbuffer_iovec</span> <span class="o">*</span><span class="n">vec</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n_vecs</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p><code>evbuffer_reserve_space()</code>函数返回evbuffer内部的指针，它根据需要决定是否扩展缓冲区，以便足以容纳size字节。vec中的指针指向这些扩展，n_vecs为数组的长度。</p>
<p>n_vecs的值最小必须为1，如果你只提供了一个vector，libevent将确保你所请求的空间分配在单个连续的扩展中，但是为了达到此目的，可能会重新排列内存、内存浪费。为了更好的性能，请最少提供两个vector，该函数返回你请求的空间所需的提供vector的数量。</p>
<p>在你调用 <code>evbuffer_commit_space()</code> 之前，您写入这些vector的数据不是缓冲区的一部分，这实际上使你写入的数据算作在缓冲区中。如果你想提交比你要求的更少的空间，你可以减少任何给定的 <code>evbuffer_iovec</code> 结构中的 <code>iov_len</code> 字段。您还可以传回比给定的更少的vector。 <code>evbuffer_commit_space()</code> 函数在成功时返回 0，在失败时返回 -1。</p>
<p><strong>注意</strong></p>
<ul>
<li>调用任何重新排列 evbuffer 或向evbuffer 添加数据的函数，将使您从 <code>evbuffer_reserve_space()</code> 获得的指针无效。</li>
<li>在当前实现中，<code>evbuffer_reserve_space()</code>从不使用两个以上的vector，而不论用户提供了多少。这可能会在未来的版本中改变。</li>
<li>不论调用多少次<code>evbuffer_reserve_space()</code>，总是安全的。</li>
<li>如果你的evbuffer可能在多线程中使用，确保在调用<code>evbuffer_reserve_space()</code>函数之前调用<code>evbuffer_lock()</code>，并在提交之后解锁。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/* Suppose we want to fill a buffer with 2048 bytes of output from a
</span><span class="cm">   generate_data() function, without copying. */</span>
<span class="k">struct</span> <span class="nc">evbuffer_iovec</span> <span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
<span class="n">size_t</span> <span class="n">n_to_add</span> <span class="o">=</span> <span class="mi">2048</span><span class="p">;</span>

<span class="cm">/* Reserve 2048 bytes.*/</span>
<span class="n">n</span> <span class="o">=</span> <span class="n">evbuffer_reserve_space</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">n_to_add</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">)</span>
   <span class="k">return</span><span class="p">;</span> <span class="cm">/* Unable to reserve the space for some reason. */</span>

<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">n_to_add</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">iov_len</span><span class="p">;</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">n_to_add</span><span class="p">)</span> <span class="cm">/* Don&#39;t write more than n_to_add bytes. */</span>
      <span class="n">len</span> <span class="o">=</span> <span class="n">n_to_add</span><span class="p">;</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">generate_data</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">iov_base</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="cm">/* If there was a problem during data generation, we can just stop
</span><span class="cm">         here; no data will be committed to the buffer. */</span>
      <span class="k">return</span><span class="p">;</span>
   <span class="p">}</span>
   <span class="cm">/* Set iov_len to the number of bytes we actually wrote, so we
</span><span class="cm">      don&#39;t commit too much. */</span>
   <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">iov_len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* We commit the space here.  Note that we give it &#39;i&#39; (the number of
</span><span class="cm">   vectors we actually used) rather than &#39;n&#39; (the number of vectors we
</span><span class="cm">   had available. */</span>
<span class="k">if</span> <span class="p">(</span><span class="n">evbuffer_commit_space</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
   <span class="k">return</span><span class="p">;</span> <span class="cm">/* Error committing */</span>
</code></pre></td></tr></table>
</div>
</div><p>反例</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/* Here are some mistakes you can make with evbuffer_reserve().
</span><span class="cm">   DO NOT IMITATE THIS CODE. */</span>
<span class="k">struct</span> <span class="nc">evbuffer_iovec</span> <span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

<span class="p">{</span>
  <span class="cm">/* Do not use the pointers from evbuffer_reserve_space() after
</span><span class="cm">     calling any functions that modify the buffer. */</span>
  <span class="n">evbuffer_reserve_space</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">1024</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
  <span class="n">evbuffer_add</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&#34;X&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="cm">/* WRONG: This next line won&#39;t work if evbuffer_add needed to rearrange
</span><span class="cm">     the buffer&#39;s contents.  It might even crash your program. Instead,
</span><span class="cm">     you add the data before calling evbuffer_reserve_space. */</span>
  <span class="n">memset</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">iov_base</span><span class="p">,</span> <span class="sc">&#39;Y&#39;</span><span class="p">,</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">iov_len</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
  <span class="n">evbuffer_commit_space</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="p">{</span>
  <span class="cm">/* Do not modify the iov_base pointers. */</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="s">&#34;Here is some data&#34;</span><span class="p">;</span>
  <span class="n">evbuffer_reserve_space</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">v</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="cm">/* WRONG: The next line will not do what you want.  Instead, you
</span><span class="cm">     should _copy_ the contents of data into v[0].iov_base. */</span>
  <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">iov_base</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>
  <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">iov_len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
  <span class="cm">/* In this case, evbuffer_commit_space might give an error if you&#39;re
</span><span class="cm">     lucky */</span>
  <span class="n">evbuffer_commit_space</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="evbuffer与网路io">evbuffer与网路IO</h4>
<p>libevent中evbuffer最常见用例是网络IO，在evbuffer上的网络IO的接口是：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="kt">int</span> <span class="nf">evbuffer_write</span><span class="p">(</span><span class="k">struct</span> <span class="nc">evbuffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="n">evutil_socket_t</span> <span class="n">fd</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">evbuffer_write_atmost</span><span class="p">(</span><span class="k">struct</span> <span class="nc">evbuffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="n">evutil_socket_t</span> <span class="n">fd</span><span class="p">,</span>
        <span class="n">ev_ssize_t</span> <span class="n">howmuch</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">evbuffer_read</span><span class="p">(</span><span class="k">struct</span> <span class="nc">evbuffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="n">evutil_socket_t</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">howmuch</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p><code>evbuffer_read()</code>函数在指定的fd上读取<code>howmuch</code>字节的数据到buffer的尾部，如果成功的话，返回读取的字节数，如果遇到EOF返回0，如果遇到错误的话，返回-1。请注意，该错误可能表明非阻塞操作不会成功，你可能需要检查<code>EAGAIN</code>的错误码（在windows上位WSAEWOULDBLOCK），如果<code>howmuch</code>是负值，<code>evbuffer_read()</code>函数将自己猜测需要读取多少数据。</p>
<p><code>evbuffer_write_atmost()</code>函数尝试从buffer的头部，取出<code>howmuch</code>字节长度的数据，写入fd，在成功时返回实际写入的字节数，在失败时返回-1。和<code>evbuffer_read()</code>函数一样，你需要检查检查错误代码以检查错误是否真实，或者只是表示无法立即完成非阻塞IO，如果<code>howmuch</code>传入了一个负值，则尝试写入整个buffer。</p>
<p>调用<code>evbuffer_write()</code>函数和调用<code>evbuffer_write_atmost()</code>函数时以负值传入howmuch，效果是一样的，它尽可能多的写入数据。</p>
<p>在unix上，这些函数在任何支持读写的文件描述符上都可以工作。在Windows上，仅仅支持套接字。</p>
<p>请注意，当你使用bufferevent的时候，不要调用这些IO函数，bufferevent会自动帮你做这些。</p>
<h4 id="evbuffer和回调">evbuffer和回调</h4>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Liu Guangxuan</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2021-09-13
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/libevent/">libevent</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/cmake%E9%A1%B9%E7%9B%AE%E7%A4%BA%E4%BE%8B/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">CMake项目示例</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/bufferevents%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98/">
            <span class="next-text nav-default">Bufferevents：高级主题</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="guangxuanliu/guangxuanliu.github.io"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:guangxuanliu@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="https://github.com/guangxuanliu" class="iconfont icon-github" title="github"></a>
      <a href="https://weibo.com/u/2361526901" class="iconfont icon-weibo" title="weibo"></a>
  <a href="https://guangxuanliu.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span>Liu Guangxuan</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>








</body>
</html>
